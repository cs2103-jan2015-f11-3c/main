//@author: a0111378j



	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DLogic\E2DLogic.cpp
	 */

#include "E2DLogic.h"
#include "E2DInputFeedback.h"
#include "E2DStorage.h"
#include "E2DLogging.h"
#include "E2DHistory.h"
#include "E2DSaveLoad.h"

const std:: string E2DLogic::STRING_BLANK = "";
const std:: string E2DLogic::SEVERITY_LEVEL_WARNING = "Warning";
const std:: string E2DLogic::SEVERITY_LEVEL_INFO = "Info";
const std:: string E2DLogic::SEVERITY_LEVEL_ERROR = "Error";
const std:: string E2DLogic::MESSAGE_LOG_INVALID = "Invalid User Input";
const std:: string E2DLogic::MESSAGE_END_USAGE = "end of previous usage";

const std:: string E2DLogic::COMMAND_INVALID = "invalid";
const std:: string E2DLogic::COMMAND_ADD = "add";
const std:: string E2DLogic::COMMAND_SHORTCUT_ADD = "a";
const std:: string E2DLogic::COMMAND_DELETE = "delete";
const std:: string E2DLogic::COMMAND_SHORTCUT_DELETE = "del";
const std:: string E2DLogic::COMMAND_CLEAR = "clear";
const std:: string E2DLogic::COMMAND_SHORTCUT_CLEAR = "clr";
const std:: string E2DLogic::COMMAND_EXIT = "exit";
const std:: string E2DLogic::COMMAND_UNDO = "undo";
const std:: string E2DLogic::COMMAND_DONE = "done";
const std:: string E2DLogic::COMMAND_SHORTCUT_DONE = "d";
const std:: string E2DLogic::COMMAND_UPDATE = "update";
const std:: string E2DLogic::COMMAND_SHORTCUT_UPDATE = "up";
const std:: string E2DLogic::COMMAND_SAVE = "save";
const std:: string E2DLogic::COMMAND_FILTER = "filter";
const std:: string E2DLogic::COMMAND_SHORTCUT_FILTER = "fil";
const std:: string E2DLogic::COMMAND_DISPLAY = "display";
const std:: string E2DLogic::COMMAND_SHORTCUT_DISPLAY = "dis";
const std:: string E2DLogic::COMMAND_SEARCH = "search";
const std:: string E2DLogic::COMMAND_SHORTCUT_SEARCH = "src";
const std:: string E2DLogic::COMMAND_TODAY = "today";
const std:: string E2DLogic::COMMAND_UPCOMING = "upcoming";
const std:: string E2DLogic::COMMAND_FLOAT = "float";

const std:: string E2DLogic::MESSAGE_ADD = "Task \"%s\" is added successfully";
const std:: string E2DLogic::MESSAGE_INVALID = "ERROR! Invalid Command";
const std:: string E2DLogic::MESSAGE_NOTFOUND = "Task is not found!";

const std:: string E2DLogic::MESSAGE_DELETETODAY = "Today Task %s is deleted!";
const std:: string E2DLogic::MESSAGE_DELETEUPCOMING = "Upcoming Task %s is deleted!";
const std:: string E2DLogic::MESSAGE_DELETEFLOATING = "Floating Task %s is deleted!";

const std:: string E2DLogic::MESSAGE_DONETODAY = "Today Task %s is done!";
const std:: string E2DLogic::MESSAGE_DONEUPCOMING = "Upcoming Task %s is done!";
const std:: string E2DLogic::MESSAGE_DONEFLOATING = "Floating Task %s is done!";

const std:: string E2DLogic::MESSAGE_CLEARALL = "All task(s) are deleted!";
const std:: string E2DLogic::MESSAGE_CLEARTODAY = "Today's task(s) are deleted!";
const std:: string E2DLogic::MESSAGE_CLEARUPCOMING = "Upcoming task(s) are deleted!";
const std:: string E2DLogic::MESSAGE_CLEARFLOATING = "Floating task(s) are deleted!";
const std:: string E2DLogic::MESSAGE_STORAGEEMPTY = "Task List is already empty!";

const std:: string E2DLogic::MESSAGE_UPDATETODAY = "Today Task %s is updated successfully";
const std:: string E2DLogic::MESSAGE_UPDATEUPCOMING = "Upcoming Task %s is updated successfully";
const std:: string E2DLogic::MESSAGE_UPDATEFLOATING = "Floating Task %s is updated successfully";

const std:: string E2DLogic::MESSAGE_DISPLAY = "All tasks are displayed";

const std:: string E2DLogic::MESSAGE_ALL = "all";
const std:: string E2DLogic::MESSAGE_TODAY = "today";
const std:: string E2DLogic::MESSAGE_UPCOMING = "upcoming";
const std:: string E2DLogic::MESSAGE_FLOATING = "float";

const std:: string E2DLogic::MESSAGE_UNDOINVALID = "No more action left to undo";

const std:: string E2DLogic::DEFAULT_YEAR = "2015,"; 

std:: string E2DLogic::_command;
std:: string E2DLogic::_content;
std:: string E2DLogic::_contentDescription;
std:: string E2DLogic::_contentStartDay;
std:: string E2DLogic::_contentStartMonth;
std:: string E2DLogic::_contentStartHours;
std:: string E2DLogic::_contentStartMinutes;
std:: string E2DLogic::_contentEndDay;
std:: string E2DLogic::_contentEndMonth;
std:: string E2DLogic::_contentEndHours;
std:: string E2DLogic::_contentEndMinutes;
std:: string E2DLogic::_taskType;
std:: string E2DLogic::_taskID;

std:: vector<std:: string> E2DLogic::parserVector;
char E2DLogic::buffer[MAX];

E2DLogic::E2DLogic(){
}

void E2DLogic::pushParserVector(std:: vector<std:: string>& temp) {
	parserVector.clear();
	std:: vector<std:: string>::iterator iter;
	iter = temp.begin();
	assert((*iter) != "");
	for(iter = temp.begin(); iter != temp.end(); iter++) {
		parserVector.push_back(*iter);
	}
	determineCommand();
} 

void E2DLogic::determineCommand(){
	assert(parserVector[0] != STRING_BLANK);

	std:: string feedback;
	std:: vector<std:: string> feedbackList;
	
	if(parserVector[0] == COMMAND_INVALID) {
		sprintf_s(buffer, MESSAGE_INVALID.c_str());
		E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__ , std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
		feedback = buffer;
	} else {
		initializeCommand();
		feedback = executeCommand();
	}

	E2DInputFeedback::addToMasterFeedbackList(feedback);
}

void E2DLogic::initializeCommand() {
	std:: vector<std:: string>::iterator iter;
	iter = parserVector.begin();

	_command = *iter;
	iter++;
	_taskType = *iter;
	iter++;
	_taskID = *iter;
	iter++;
	_contentDescription = *iter;
	iter++;
	_contentStartDay = *iter;
	iter++;
	_contentStartMonth= *iter;
	iter++;
	_contentStartHours= *iter;
	iter++;
	_contentStartMinutes= *iter;
	iter++;
	_contentEndDay = *iter;
	iter++;
	_contentEndMonth = *iter;
	iter++;
	_contentEndHours= *iter;
	iter++;
	_contentEndMinutes= *iter;
	
	if(_command == STRING_BLANK) {
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), "E2DParser fail to pass me valid parserVector");
		assert(_command != STRING_BLANK);
	}
}

std:: string E2DLogic::executeCommand() { 
	CommandType commandTypeAction = determineCommandType(_command);

	switch(commandTypeAction) { 
	case ADD: 
		E2DHistory::addPreviousAction(_command);
		return addTask(_contentDescription, _contentStartDay, _contentStartMonth, _contentStartHours, 
					   _contentStartMinutes, _contentEndDay, _contentEndMonth, _contentEndHours, _contentEndMinutes);
	case DEL:
		E2DHistory::addPreviousAction(_command);
		return deleteTask(_taskType, _taskID);
	case CLEAR:
		E2DHistory::addPreviousAction(_command);
		return clearTask(_taskType);
	case UPDATE:
		E2DHistory::addPreviousAction(_command);
		return updateTask(_taskType, _taskID, _contentDescription, _contentStartDay,
			_contentStartMonth, _contentStartHours, _contentStartMinutes, _contentEndDay, _contentEndMonth, _contentEndHours, _contentEndMinutes);
	case UNDO:
		return undoTask();
	case DONE:
		E2DHistory::addPreviousAction(_command);
		return doneTask(_taskType, _taskID);
	case SAVE:
		return E2DSaveLoad::changeSavingDirectoryAndFileName(_taskType, _taskID);
	case FILTER:
		//assert(_taskType == "18");
		//assert(_taskID == "00");
		return filterTask(_taskType, _taskID);
	case DISPLAY:
		return displayTask();
	case SEARCH:
		return searchTask(_taskType);
	case INVALID:
		E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + _command);
		sprintf_s(buffer, MESSAGE_INVALID.c_str());
		return buffer;
	case EXIT: 
		E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), MESSAGE_END_USAGE);
		exit(0);
	}
}

E2DLogic::CommandType E2DLogic::determineCommandType(std:: string commandAction) { 
	assert(commandAction != STRING_BLANK);

	if(isValidCommand(commandAction, COMMAND_ADD) || isValidCommand(commandAction, COMMAND_SHORTCUT_ADD)) { 
		return CommandType::ADD; 
	} else if(isValidCommand(commandAction, COMMAND_EXIT)) { 
		return CommandType::EXIT; 
	} else if(isValidCommand(commandAction, COMMAND_DELETE) || isValidCommand(commandAction, COMMAND_SHORTCUT_DELETE)) {
		return CommandType::DEL;
	} else if(isValidCommand(commandAction, COMMAND_CLEAR) || isValidCommand(commandAction, COMMAND_SHORTCUT_CLEAR)) {
		return CommandType::CLEAR;
	} else if(isValidCommand(commandAction, COMMAND_UPDATE) || isValidCommand(commandAction, COMMAND_SHORTCUT_UPDATE)) {
		return CommandType::UPDATE;
	} else if(isValidCommand(commandAction, COMMAND_UNDO)) {
		return CommandType::UNDO;
	} else if(isValidCommand(commandAction, COMMAND_DONE) || isValidCommand(commandAction, COMMAND_SHORTCUT_DONE)) {
		return CommandType::DONE;
	} else if(isValidCommand(commandAction, COMMAND_SAVE)) {
		return CommandType::SAVE;
	} else if(isValidCommand(commandAction, COMMAND_FILTER) || isValidCommand(commandAction, COMMAND_SHORTCUT_FILTER)) {
		return CommandType::FILTER;
	} else if(isValidCommand(commandAction, COMMAND_DISPLAY) || isValidCommand(commandAction, COMMAND_SHORTCUT_DISPLAY)) {
		return CommandType::DISPLAY;
	} else if(isValidCommand(commandAction, COMMAND_SEARCH) || isValidCommand(commandAction, COMMAND_SHORTCUT_SEARCH)) {
		return CommandType::SEARCH;
	} else { 
		return CommandType::INVALID;
	} 
}

bool E2DLogic::isValidCommand(const std:: string& str1, const std:: string& str2) { 
	if (str1.size() != str2.size()) { 
		return false; 
	} 
	std:: string::const_iterator c1;
	std:: string::const_iterator c2;

	for (c1 = str1.begin(), c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) {
		if (tolower(*c1) != tolower(*c2)) { 
			return false; 
		} 
	} return true; 
}

std:: string E2DLogic::addTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
								std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes) {
	assert(_contentDescription != "");

	// check the validity of the time period, month, day, date
	try {
		if(_contentEndDay != STRING_BLANK) {
			if(!isDateValid(_contentEndDay,_contentEndMonth)) {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "endDay/endMonth is not valid");
				throw MESSAGE_INVALID;
			} 
		}

		if(_contentStartDay!= STRING_BLANK){
			if(!isDateValid(_contentStartDay,_contentStartMonth)) {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__),  MESSAGE_LOG_INVALID + ": " + "startDay/startMonth is not valid");
				throw MESSAGE_INVALID;
			} 

			if(_contentEndHours!= STRING_BLANK && _contentEndDay == STRING_BLANK) {
				if(!isTimedTimeValid(_contentStartHours,_contentStartMinutes,_contentEndHours,_contentEndMinutes)) {
					E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "startHr/startMin/endHr/endMin is not valid");
					throw MESSAGE_INVALID;
				}
			} else if(_contentEndHours!= STRING_BLANK) {
				if(!isMultiTimeValid(_contentStartDay,_contentStartMonth,_contentStartHours,_contentStartMinutes,_contentEndDay,_contentEndMonth,_contentEndHours,_contentEndMinutes)) {
					E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "startDay/startMon/startHr/startMin/endDay/endMon/endHr/endMin is not valid");
					throw MESSAGE_INVALID;
				}
			} else if(!isDeadlineTimeValid(_contentStartHours,_contentStartMinutes)) {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__),  MESSAGE_LOG_INVALID + ": " + "startHr/startMin is not valid");
				throw MESSAGE_INVALID;
			}
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		return buffer;
	}

	E2DStorage::addToMasterStorage(_contentDescription, _contentStartDay, _contentStartMonth, _contentStartHours,
		_contentStartMinutes, _contentEndDay, _contentEndMonth, _contentEndHours, _contentEndMinutes);

	_content = concatenateString(parserVector);
	sprintf_s(buffer, MESSAGE_ADD.c_str(), _content.c_str());
	return buffer;
}

bool E2DLogic::isDateValid(std:: string contentDay, std:: string contentMonth) {

	Months monthType = determineMonthType(contentMonth);
	int intDay = stringToInteger(contentDay);
	try {
		if (( monthType == Months::JAN) || (monthType == Months::MAR) || (monthType == Months::MAY ) || (monthType == Months::JUL )
			|| (monthType == Months::AUG ) || (monthType == Months::OCT) || (monthType == Months::DEC ) ) {
				if ((intDay >= 1) && (intDay <= 31)) {
					return true;
				} else {
					throw MESSAGE_INVALID;
				}
		} else if (( monthType == Months::APR) || (monthType == Months::JUN) || (monthType == Months::SEP ) || (monthType == Months::NOV )) {
			if ((intDay >= 1) && (intDay <= 30)) {
				return true;
			} else {
				throw MESSAGE_INVALID;
			}
		} else if( monthType == Months::FEB) {
			if ((intDay >= 1) && (intDay <= 28)) {
				return true;
			} else {
				throw MESSAGE_INVALID;
			}
		} else {
			throw MESSAGE_INVALID;
		}
	} catch (std:: string& exceptionMessage) {
		return false;
	}
}

E2DLogic::Months E2DLogic::determineMonthType(std:: string parserInput) {
	if(isValidCommand(parserInput, "jan") || isValidCommand(parserInput, "january")) { 
		return Months::JAN;
	} else if(isValidCommand(parserInput, "feb") || isValidCommand(parserInput, "february")) { 
		return Months::FEB; 
	} else if(isValidCommand(parserInput, "mar") || isValidCommand(parserInput, "march")) {
		return Months::MAR;
	} else if(isValidCommand(parserInput, "apr") || isValidCommand(parserInput, "april")) {
		return Months::APR;
	} else if(isValidCommand(parserInput, "may")) {
		return Months::MAY;
	} else if(isValidCommand(parserInput, "jun") || isValidCommand(parserInput, "june")) {
		return Months::JUN;
	} else if(isValidCommand(parserInput, "jul") || isValidCommand(parserInput, "july")) {
		return Months::JUL;
	} else if(isValidCommand(parserInput, "aug") || isValidCommand(parserInput, "august")) {
		return Months::AUG;
	} else if(isValidCommand(parserInput, "sep") || isValidCommand(parserInput, "september")) {
		return Months::SEP;
	} else if(isValidCommand(parserInput, "oct") || isValidCommand(parserInput, "october")) {
		return Months::OCT;
	} else if(isValidCommand(parserInput, "nov") || isValidCommand(parserInput, "november")) {
		return Months::NOV;
	} else if(isValidCommand(parserInput, "dec") || isValidCommand(parserInput, "december")) {
		return Months::DEC;
	} else { 
		return Months::NOTVALID;
	} 
}

int E2DLogic::stringToInteger(std:: string input) {
	int output;
	output = atoi(input.c_str()); 
	return output;
}

std:: string E2DLogic::concatenateString(std:: vector<std:: string>& parserVector) {
	std:: vector<std:: string>::iterator iter;
	std:: string temp;
	for(iter = parserVector.begin() + 1; iter != parserVector.end(); iter++) {
		if(*iter != "") {
			temp += *iter;
			temp += " ";
		}
	}

	return trimTrailingSpaces(temp);
}

std:: string E2DLogic::trimTrailingSpaces(std:: string buffer) {
	boost::algorithm::trim(buffer);
	return buffer;
}

bool E2DLogic::isTimedTimeValid(std:: string startHour, std:: string startMin, std::string endHour, std::string endMin) {
	int startIntHour = stringToInteger(startHour);
	int startIntMin = stringToInteger(startMin);
	int endIntHour = stringToInteger(endHour);
	int endIntMin = stringToInteger(endMin);

	if ((startIntHour < 0) || (startIntHour > 24)) {
		return false;
	} else if ((startIntMin < 0) || (startIntMin > 60)) {
		return false;
	} else if ((endIntHour < 0) || (endIntHour > 24)) {
		return false;
	} else if ((endIntMin < 0) || (endIntMin > 60)) {
		return false;
	} else if (startIntHour > endIntHour ) {
		return false;
    } else if (startIntHour == endIntHour ) {
		if ( startIntMin > endIntMin)
		return false;
	} else {
		return true;
	}
}

bool E2DLogic::isMultiTimeValid(std::string startDay,std::string startMonth,std::string startHour,std::string startMin,std::string endDay,std::string endMonth,std::string endHour, std::string endMin) {
	int startIntHour = stringToInteger(startHour);
	int startIntMin = stringToInteger(startMin);
	int endIntHour = stringToInteger(endHour);
	int endIntMin = stringToInteger(endMin);

	std::string startDateString = DEFAULT_YEAR +  startMonth + "," + startDay;
	date d1(from_string(startDateString));
	ptime temp1(d1, time_duration(hours(stringToInteger(startHour))+minutes(stringToInteger(startMin))));

	std::string endDateString = DEFAULT_YEAR + endMonth + "," + endDay;
	date d2(from_string(endDateString));
	ptime temp2(d2,time_duration(hours(stringToInteger(endHour))+minutes(stringToInteger(endMin))));


	if( temp1 > temp2 ) {
		return false; 
	} else if ((startIntHour < 0) || (startIntHour > 24)) {
		return false;
	} else if ((startIntMin < 0) || (startIntMin > 60)) {
		return false;
	} else if ((endIntHour < 0) || (endIntHour > 24)) {
		return false;
	} else if ((endIntMin < 0) || (endIntMin > 60)) {
		return false;
	} else {
		return true;
	}
}

bool E2DLogic::isDeadlineTimeValid(std:: string startHour, std:: string startMin) {
	int startIntHour = stringToInteger(startHour);
	int startIntMin = stringToInteger(startMin);

	if ((startIntHour < 0) || (startIntHour > 24)) {
		return false;
	} else if ((startIntMin < 0) || (startIntMin > 60)) {
		return false;
	} else {
		return true;
	}
}

std:: string E2DLogic::deleteTask(std:: string taskType, std:: string taskID) {
	assert(taskID !=  STRING_BLANK);
	assert(taskType != STRING_BLANK);

	const std:: string temp = taskID;
	int ID = stringToInteger(taskID); 
	DateType commandTypeAction = determineDateTypeAction(taskType);
	std:: vector<TASK>::iterator iter;

	try {
		switch(commandTypeAction) {
		case TODAY:
			if(isTodayTaskIDValid(ID)) {
				iter = E2DStorage::findTodayIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::deleteTodayFromStorage(iter);
				sprintf_s(buffer, MESSAGE_DELETETODAY.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"today\"");
				throw MESSAGE_NOTFOUND;
			}
		case UPCOMING:
			if(isUpcomingTaskIDValid(ID)) {
				iter = E2DStorage::findUpcomingIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::deleteUpcomingFromStorage(iter);
				sprintf_s(buffer, MESSAGE_DELETEUPCOMING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"upcoming\"");
				throw MESSAGE_NOTFOUND;
			}
		case FLOAT:
			if(isFloatingTaskIDValid(ID)) {
				iter = E2DStorage::findFloatingIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::deleteFloatingFromStorage(iter);
				sprintf_s(buffer, MESSAGE_DELETEFLOATING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"Float\"");
				throw MESSAGE_NOTFOUND;
			}	
		case UNVALID:
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "invalid taskType input");
			throw MESSAGE_INVALID;
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		return buffer;
	}
}

E2DLogic::DateType E2DLogic::determineDateTypeAction(std:: string taskType) {
	assert(taskType != STRING_BLANK);

	if(isValidCommand(taskType, COMMAND_TODAY)) { 
		return DateType::TODAY; 
	} else if(isValidCommand(taskType, COMMAND_UPCOMING)) { 
		return DateType::UPCOMING; 
	} else if(isValidCommand(taskType, COMMAND_FLOAT)) {
		return DateType::FLOAT;
	} else {
		return DateType::UNVALID;
	}
}

bool E2DLogic::isTodayTaskIDValid(int taskID) {
	int size = E2DStorage::findTotalNumberofTodayTask();
	assert(size >=0);
	if(size < taskID) {
		return false;
	} else {
		return true;
	}
}

bool E2DLogic::isUpcomingTaskIDValid(int taskID) {
	int size = E2DStorage::findTotalNumberofUpcomingTask();
	assert(size >=0);
	if(size < taskID) {
		return false;
	} else {
		return true;
	}
}

bool E2DLogic::isFloatingTaskIDValid(int taskID) {
	int size = E2DStorage::findTotalNumberofFloatingTask();
	assert(size >=0);
	if(size < taskID) {
		return false;
	} else {
		return true;
	}
}

std:: string E2DLogic::clearTask(std:: string _content) {
	assert(_content != STRING_BLANK);

	try {
		if (_taskType == MESSAGE_ALL) {
			if(isMasterTaskListEmpty() && isFloatingTaskListEmpty()) {
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), "All tasklists are already cleared");
				throw MESSAGE_STORAGEEMPTY;
			} else {
				E2DStorage::clearAllFromStorage();
				throw MESSAGE_CLEARALL;
			}
		}

		if(_taskType == MESSAGE_TODAY) {
			if(isTodayTaskListEmpty()) {
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), "todayTaskList is already cleared");
				throw MESSAGE_STORAGEEMPTY;
			} else {
				E2DStorage::clearTodayFromStorage();
				throw MESSAGE_CLEARTODAY;
			}
		}

		if(_taskType == MESSAGE_UPCOMING) {
			if(isUpcomingTaskListEmpty()) {
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), "upcomingTaskList is already cleared");
				throw MESSAGE_STORAGEEMPTY;
			} else {
				E2DStorage::clearUpcomingFromStorage();
				throw MESSAGE_CLEARUPCOMING;
			}
		}

		if(_taskType == MESSAGE_FLOATING) {
			if(isFloatingTaskListEmpty()) {
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), "floatingTaskList is already cleared");
				throw MESSAGE_STORAGEEMPTY;
			} else {
				E2DStorage::clearFloatingFromStorage();
				throw MESSAGE_CLEARFLOATING;
			}
		} else {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
			throw MESSAGE_INVALID;
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		return buffer;
	}
}

bool E2DLogic::isMasterTaskListEmpty() {
	return E2DStorage::isMasterTaskListEmpty();
}

bool E2DLogic::isTodayTaskListEmpty() {
	return E2DStorage::isTodayTaskListEmpty();
}

bool E2DLogic::isUpcomingTaskListEmpty() {
	return E2DStorage::isUpcomingTaskListEmpty();
}

bool E2DLogic::isFloatingTaskListEmpty() {
	return E2DStorage::isFloatingTaskListEmpty();
}

std:: string E2DLogic::updateTask(std:: string taskType, std:: string taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
									std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes) {
	const std:: string temp = taskID;
	int ID = stringToInteger(taskID);
	DateType commandTypeAction = determineDateTypeAction(taskType);
	assert(ID > 0);
	if(newTask == STRING_BLANK) {
		E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
		assert(newTask != STRING_BLANK);
	}

	try {
		switch(commandTypeAction) {
		case TODAY:
			if(isTodayTaskIDValid(ID)) {
				E2DStorage::updateToTodayStorage(ID, newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);
				sprintf_s(buffer, MESSAGE_UPDATETODAY.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"today\"");
				throw MESSAGE_NOTFOUND;
			}
		case UPCOMING:
			if(isUpcomingTaskIDValid(ID)) {
				E2DStorage::updateToUpcomingStorage(ID, newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);
				sprintf_s(buffer, MESSAGE_UPDATEUPCOMING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"upcoming\"");
				throw MESSAGE_NOTFOUND;
			}
		case FLOAT:
			if(isFloatingTaskIDValid(ID)) {
				E2DStorage::updateToFloatingStorage(ID, newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);
				sprintf_s(buffer, MESSAGE_UPDATEFLOATING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"floating\"");
				throw MESSAGE_NOTFOUND;
			}
		case UNVALID:
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
			throw MESSAGE_INVALID;
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		return buffer;
	}
}

std:: string E2DLogic::undoTask() {
	std:: string feedback;
	if(E2DHistory::isUndoStackEmpty()) {
		E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
		sprintf_s(buffer, MESSAGE_UNDOINVALID.c_str());
		return buffer;
	} else {
		feedback = E2DHistory::undoAction();
		return feedback;
	}
}

std:: string E2DLogic::doneTask(std:: string taskType, std:: string taskID) {
	if(taskType == STRING_BLANK) {
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + "E2DParser is not tokenizing properly");
		assert(taskType !=  STRING_BLANK);
	}
	if(taskID == STRING_BLANK) {
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + "E2DParser is not tokenizing properly");
		assert(taskID != STRING_BLANK);
	}

	const std:: string temp = taskID;
	int ID = stringToInteger(taskID); 
	DateType commandTypeAction = determineDateTypeAction(taskType);
	std:: vector<TASK>::iterator iter;

	try {
		switch(commandTypeAction) {
		case TODAY:
			if(isTodayTaskIDValid(ID)) {
				iter = E2DStorage::findTodayIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::doneTodayTask(iter);
				sprintf_s(buffer, MESSAGE_DONETODAY.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"today\"");
				throw MESSAGE_NOTFOUND;
			}
		case UPCOMING:
			if(isUpcomingTaskIDValid(ID)) {
				iter = E2DStorage::findUpcomingIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::doneUpcomingTask(iter);
				sprintf_s(buffer, MESSAGE_DONEUPCOMING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"upcoming\"");
				throw MESSAGE_NOTFOUND;
			}
		case FLOAT:
			if(isFloatingTaskIDValid(ID)) {
				iter = E2DStorage::findFloatingIterator(ID);
				E2DHistory::addPreviousState(*iter);
				E2DStorage::doneFloatingTask(iter);
				sprintf_s(buffer, MESSAGE_DONEFLOATING.c_str(), temp.c_str());
				return buffer;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found in \"Float\"");
				throw MESSAGE_NOTFOUND;
			}
		case UNVALID:
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID);
			throw MESSAGE_INVALID;
		}
	} catch(std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		return buffer;
	}
}

std:: string E2DLogic::filterTask(std:: string dayOrHour, std:: string monthOrMin) {
	Months monthType = determineMonthType(monthOrMin);
	std:: string feedback;

	if(E2DStorage::isMasterTaskListEmpty() && E2DStorage::isFloatingTaskListEmpty()) {
		E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), MESSAGE_STORAGEEMPTY);
		sprintf_s(buffer, MESSAGE_STORAGEEMPTY.c_str());
		return buffer;
	} else if (monthType != Months::NOTVALID) { // the user input is a date and month e.g filter 14 may
		if(!isDateValid(dayOrHour,monthOrMin)) {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__),  MESSAGE_LOG_INVALID + ": " + "invalid day/month input");
			sprintf_s(buffer, MESSAGE_INVALID.c_str());
			return buffer;
		} else {
			feedback = E2DStorage::filterTaskByDayAndMonth(dayOrHour, monthOrMin);
			return feedback;
		}
	} else { // invalid month -> assuming the user input is a time
		if(!isDeadlineTimeValid(dayOrHour, monthOrMin)) {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__),  MESSAGE_LOG_INVALID + ": " + "invalid time input");
			sprintf_s(buffer, MESSAGE_INVALID.c_str());
			return buffer;
		} else {
			feedback = E2DStorage::filterTaskByHrAndMin(dayOrHour, monthOrMin);
			return feedback;
		}
	}
}

std:: string E2DLogic::displayTask() {
	if(E2DStorage::isMasterTaskListEmpty() && E2DStorage::isFloatingTaskListEmpty()) {
		E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), MESSAGE_STORAGEEMPTY);
		sprintf_s(buffer, MESSAGE_STORAGEEMPTY.c_str());
		return buffer;
	} else {
		E2DStorage::displayTaskInStorage();
		sprintf_s(buffer, MESSAGE_DISPLAY.c_str());
		return buffer;
	}
}

std:: string E2DLogic::searchTask(std:: string searchContent) {
	assert(searchContent != STRING_BLANK);

	if(E2DStorage::isMasterTaskListEmpty() && E2DStorage::isFloatingTaskListEmpty()) {
		E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__, std:: to_string(__LINE__), MESSAGE_STORAGEEMPTY);
		sprintf_s(buffer, MESSAGE_STORAGEEMPTY.c_str());
		return buffer;
	} else {
		std:: string feedback;
		feedback = E2DStorage::searchContentInStorage(searchContent);
		return feedback;
	}
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DLogic\E2DLogic.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DLogic\E2DLogic.h
	 */

#ifndef E2DLOGIC_H_
#define E2DLOGIC_H_

#include <iostream>
#include <string>
#include <stack>
#include <vector>
#include <sstream>
#include <boost/algorithm/string.hpp>

#undef DELETE

// to do list requires basic support of storage/retrieval of info, display of info to user and updating 
// existing info. thus to reduce coupling from the innate nature of interlinkedness, we separated the
// architecture to 8 different components of UI, InputFeedBack, Parser, Logic, Storage, History, SaveLoad, Boost

// architectureLogic is responsible for all the "thinking" in the program
// being the facade of this program, it will separate the user from the storage variables
class E2DLogic
{
private:
	static const std:: string STRING_BLANK;
	static const std:: string SEVERITY_LEVEL_WARNING;
	static const std:: string SEVERITY_LEVEL_INFO;
	static const std:: string SEVERITY_LEVEL_ERROR;
	static const std:: string MESSAGE_LOG_INVALID;
	static const std:: string MESSAGE_END_USAGE;
	static const std:: string COMMAND_INVALID;
	static const std:: string COMMAND_ADD;
	static const std:: string COMMAND_SHORTCUT_ADD;
	static const std:: string COMMAND_DELETE;
	static const std:: string COMMAND_SHORTCUT_DELETE;
	static const std:: string COMMAND_CLEAR;
	static const std:: string COMMAND_SHORTCUT_CLEAR;
	static const std:: string COMMAND_EXIT;
	static const std:: string COMMAND_UNDO;
	static const std:: string COMMAND_DONE;
	static const std:: string COMMAND_SHORTCUT_DONE;
	static const std:: string COMMAND_UPDATE;
	static const std:: string COMMAND_SHORTCUT_UPDATE;
	static const std:: string COMMAND_SAVE;
	static const std:: string COMMAND_FILTER;
	static const std:: string COMMAND_SHORTCUT_FILTER;
	static const std:: string COMMAND_DISPLAY;
	static const std:: string COMMAND_SHORTCUT_DISPLAY;
	static const std:: string COMMAND_SEARCH;
	static const std:: string COMMAND_SHORTCUT_SEARCH;
	static const std:: string COMMAND_TODAY;
	static const std:: string COMMAND_UPCOMING;
	static const std:: string COMMAND_FLOAT;
	static const std:: string MESSAGE_ADD;
	static const std:: string MESSAGE_INVALID;
	static const std:: string MESSAGE_NOTFOUND;
	static const std:: string MESSAGE_DELETETODAY;
	static const std:: string MESSAGE_DELETEUPCOMING;
	static const std:: string MESSAGE_DELETEFLOATING;
	static const std:: string MESSAGE_DONETODAY;
	static const std:: string MESSAGE_DONEUPCOMING;
	static const std:: string MESSAGE_DONEFLOATING;
	static const std:: string MESSAGE_CLEARALL;
	static const std:: string MESSAGE_CLEARTODAY;
	static const std:: string MESSAGE_CLEARUPCOMING;
	static const std:: string MESSAGE_CLEARFLOATING;
	static const std:: string MESSAGE_UPDATETODAY;
	static const std:: string MESSAGE_UPDATEUPCOMING;
	static const std:: string MESSAGE_UPDATEFLOATING;
	static const std:: string MESSAGE_DISPLAY;
	static const std:: string MESSAGE_STORAGEEMPTY;
	static const std:: string MESSAGE_TODAY;
	static const std:: string MESSAGE_UPCOMING;
	static const std:: string MESSAGE_FLOATING;
	static const std:: string MESSAGE_ALL;
	static const std:: string MESSAGE_UNDOINVALID;
	static const std:: string DEFAULT_YEAR;

	static std:: string _command;
	static std:: string _content;
	static std:: string _contentDescription;
	static std:: string _contentStartDay;
	static std:: string _contentStartMonth;
	static std:: string _contentStartHours;
	static std:: string _contentStartMinutes;
	static std:: string _contentEndDay;
	static std:: string _contentEndMonth;
	static std:: string _contentEndHours;
	static std:: string _contentEndMinutes;
	static std:: string _newTask;
	static std:: string _newTime;
	static std:: string _taskType;
	static std:: string _taskID;
	
	static const int MAX = 255;
	static char buffer[MAX];
	static std:: vector<std:: string> parserVector;
public:
	E2DLogic(void);
	~E2DLogic(void);

	enum CommandType { 
		ADD, EXIT, DEL, INVALID, CLEAR, UPDATE, UNDO, DONE, SAVE, FILTER, DISPLAY, SEARCH
	};
	enum Months { 
		JAN=1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC, NOTVALID
	};

	enum DateType {
		TODAY, UPCOMING, FLOAT, UNVALID
	};

	// this function is called by the parser to push the vector of the tokenized materials to vector
	// Pre: None. Basically it will tokenize everything
	// Post:: initiate determineCommand();
	static void pushParserVector(std:: vector<std:: string>& temp);

	// takes in a parser input to interpret the user input and initiate the action according to the first word in the vector 
	// Pre : parser will tokenize and pass me a vector of all the individual details which is in turn dependent from the user input from UI
	// Post : returns a feedback message whether each command was executed successfully which is retrieved from executeCommand which will be stored into 
	// architectureInputFeedback which will be return to the UI
	static void determineCommand();

	//this function intialize the string to the glpbal variables in a chronological order according to the vector passed from the parser
	//Pre : the first word in the vector string cannot be "invalid"
	//Post : None
	static void initializeCommand();

	// this function execute the individual command according to the _command which is initialized from the first word
	// Pre: valid function will result in the respective feedback. else unrecognised _command will result in invalid message
	// Post: return a feedback message
	static std:: string executeCommand();

	// this function allow for a flexible input where user may accidentally key in command with different casing supported by the function, isValidCommand
	// Pre: None
	// Post: return a enum commandType
	static CommandType determineCommandType(std:: string commandAction);
	static bool isValidCommand(const std:: string& str1, const std:: string& str2);

	// this function passes the global variables to the next architecture, storage, for them to be initialized into a task for storage
	// Pre: the _command is "add"
	// Post: cocantenate the tokenized variables to return a string of the details of the task added
	// the following group of functions support the add function
	static std:: string addTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
								std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes);
	static bool isDateValid(std:: string contentDay, std:: string contentMonth);
	static Months determineMonthType(std:: string parserInput);
	static int stringToInteger(std:: string input);
	static std:: string concatenateString(std:: vector<std:: string>& parserVector);
	static std:: string trimTrailingSpaces(std:: string buffer);
	static bool isTimedTimeValid(std:: string startHour, std:: string startMin, std::string endHour, std::string endMin );
	static bool isMultiTimeValid(std:: string startDay,std:: string startMonth,std:: string startHour,std:: string startMin,
													std:: string endDay,std:: string endMonth,std:: string endHour, std:: string endMin);
	static bool isDeadlineTimeValid(std:: string startHour, std:: string startMin);	

	// this function differentiate the different datatype that is required to delete and remove from the storage
	// Pre: the _command is delete, _taskType is a valid string(today, upcoming, misc) and valid taskID in the respective taskType
	// Post: return a successful deleted string message else if the task is deleted and access storage to execute the delete
	// the following group of functions support the delete function
	static std:: string deleteTask(std:: string taskType, std:: string taskID);
	static DateType determineDateTypeAction(std:: string commandAction);
	static bool isTodayTaskIDValid(int taskID);
	static bool isUpcomingTaskIDValid(int taskID);
	static bool isFloatingTaskIDValid(int taskID);

	// this function clear all the storage memory specified by the user
	// Pre: the _command is clear and the taskType is valid
	// Post: access storage to delete all the respective tasks in the taskType
	// the following group of functions support the clear function
	static std:: string clearTask(std:: string content);
	static bool isMasterTaskListEmpty();
	static bool isTodayTaskListEmpty();
	static bool isUpcomingTaskListEmpty();
	static bool isFloatingTaskListEmpty();

	// this function edit the details specified by the user. it uses the current create a new task and replace the current task by
	// using the current add and delete function
	// Pre: _command is update, taskType is valid, taskId is valid, followed by a valid task content
	// Post: access storage and delete the previous task and add in the new task
	static std:: string updateTask(std:: string taskType, std:: string taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
									std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes);
	
	// this function allows the users to undo the previous action
	// Pre:: _command is undo, or the user type ctrl-z 
	// Post: undo the previous action and return the specific feedback message 
	static std:: string undoTask();

	// this function allow users to strike out the tasks they have completed
	// Pre: _command is done, taskType is valid, taskID is valid
	// Post: access storage to change the bool variable of the task strcuture
	static std:: string doneTask(std:: string taskType, std:: string taskID);

	// this function allow the users to filter the tasks out according to the intended date. on top of that, it will display tasks that are expiring in two days time as well
	// Pre: tasklist must not be empty
	// Post: filter the task
	static std:: string filterTask(std:: string day, std:: string month);

	// this is sort of the undo function of filter and search
	// Pre: tasklist must not be empty
	// Post: display all the tasks
	static std:: string displayTask();

	// this function allow the users to search the tasks according to the intended content description
	// Pre: tasklist must not be empty
	// Post:: search the task
	static std:: string searchTask(std:: string searchContent);
};

#endif


	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DLogic\E2DLogic.h





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DHistory.cpp
	 */

#include "E2DHistory.h"
#include "E2DLogging.h"
#include "E2DStorage.h"

std:: stack<std:: string> E2DHistory::previousActionStack;
std:: stack<TASK> E2DHistory::previousStateStack;
std:: vector<TASK> E2DHistory::previousTodayUpcomingTaskList;
std:: vector<TASK> E2DHistory::previousFloatingTaskList;

const std:: string E2DHistory::COMMAND_ADD = "add";
const std:: string E2DHistory::COMMAND_SHORTCUT_ADD = "a";
const std:: string E2DHistory::COMMAND_DELETE = "delete";
const std:: string E2DHistory::COMMAND_SHORTCUT_DELETE = "del";
const std:: string E2DHistory::COMMAND_CLEAR = "clear";
const std:: string E2DHistory::COMMAND_SHORTCUT_CLEAR = "clr";
const std:: string E2DHistory::COMMAND_EXIT = "exit";
const std:: string E2DHistory::COMMAND_UNDO = "undo";
const std:: string E2DHistory::COMMAND_DONE = "done";
const std:: string E2DHistory::COMMAND_SHORTCUT_DONE = "d";
const std:: string E2DHistory::COMMAND_UPDATE = "update";
const std:: string E2DHistory::COMMAND_SHORTCUT_UPDATE = "up";

char E2DHistory::temp[MAXIMUM];

const std:: string E2DHistory::MESSAGE_ERROR = "ERROR! Invalid Command";
const std:: string E2DHistory::MESSAGE_UNDO = "Previous Action, \"%s\", has been undo";

const std:: string E2DHistory::SEVERITY_LEVEL_ERROR = "Error";

E2DHistory::E2DHistory(void) {
}


E2DHistory::~E2DHistory(void) {
}

void E2DHistory::addPreviousAction(std:: string commandAction) {
	previousActionStack.push(commandAction);
}

void E2DHistory::addPreviousState(TASK input) {
	previousStateStack.push(input);
}

bool E2DHistory::isUndoStackEmpty() {
	if(previousActionStack.empty()) {
		return true;
	} else {
		return false;
	}
}

std:: string E2DHistory::undoAction() {
	std:: string previousCommand;
	previousCommand = previousActionStack.top();
	previousActionStack.pop();
	executeUndo(previousCommand);
	sprintf_s(temp, MESSAGE_UNDO.c_str(), previousCommand.c_str());
	return temp;
}

void E2DHistory::executeUndo(std:: string previousCommand) {
	E2DHistory:: CommandType commandTypeAction = E2DHistory:: determineCommandType(previousCommand);

	switch(commandTypeAction) { 
	case ADD: 
		reverseAdd();
		break;
	case DELETE:
		reverseDelete();
		break;
	case CLEAR:
		reverseClear();
		break;
	case UPDATE:
		reverseUpdate();
	case DONE:
		reverseDone();
		break;
	case INVALID:
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), "fault in E2DHistory::executeCommand");
		break;
	case UNDO:
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), "fault in E2DHistory::executeCommand");
		break;
	case EXIT: 
		E2DLogging::logToFile(SEVERITY_LEVEL_ERROR, __FILE__, std:: to_string(__LINE__), "fault in E2DHistory::executeCommand");
		exit(0);
	}
}

E2DHistory::CommandType E2DHistory::determineCommandType(std:: string commandAction) { 
	assert(commandAction != "");

	if(isValidCommand(commandAction, COMMAND_ADD) || isValidCommand(commandAction, COMMAND_SHORTCUT_ADD)) { 
		return CommandType::ADD; 
	} else if(isValidCommand(commandAction, COMMAND_EXIT)) { 
		return CommandType::EXIT; 
	} else if(isValidCommand(commandAction, COMMAND_DELETE) || isValidCommand(commandAction, COMMAND_SHORTCUT_DELETE)) {
		return CommandType::DELETE;
	} else if(isValidCommand(commandAction, COMMAND_CLEAR) || isValidCommand(commandAction, COMMAND_SHORTCUT_CLEAR)) {
		return CommandType::CLEAR;
	} else if(isValidCommand(commandAction, COMMAND_UPDATE) || isValidCommand(commandAction, COMMAND_SHORTCUT_UPDATE)) {
		return CommandType::UPDATE;
	} else if(isValidCommand(commandAction, COMMAND_UNDO)) {
		return CommandType::UNDO;
	} else if(isValidCommand(commandAction, COMMAND_DONE) || isValidCommand(commandAction, COMMAND_SHORTCUT_DONE)) {
		return CommandType::DONE;
	} else { 
		return CommandType::INVALID;
	} 
}

bool E2DHistory::isValidCommand(const std:: string& str1, const std:: string& str2) { 
	if (str1.size() != str2.size()) { 
		return false; 
	} 
	std:: string::const_iterator c1;
	std:: string::const_iterator c2;

	for (c1 = str1.begin(), c2 = str2.begin(); c1 != str1.end(); ++c1, ++c2) {
		if (tolower(*c1) != tolower(*c2)) { 
			return false; 
		} 
	} return true; 
}

void E2DHistory::reverseDelete() {
	TASK previousState;
	previousState = retrievePreviousState();
	E2DStorage::undoDelete(previousState);
	return;
}

void E2DHistory::reverseAdd() {
	TASK previousState;
	previousState = retrievePreviousState();
	E2DStorage::undoAdd(previousState);
	return;
}

void E2DHistory::reverseUpdate() {
	TASK previousStateToAddBack;
	TASK previousStateToDelete;

	previousStateToDelete = retrievePreviousState();
	previousStateToAddBack = retrievePreviousState();

	E2DStorage::undoAdd(previousStateToDelete);
	E2DStorage::undoDelete(previousStateToAddBack);
	return;
}

void E2DHistory::reverseDone() {
	TASK previousState;
	previousState = retrievePreviousState();
	E2DStorage::undoDone(previousState);
	return;
}

TASK E2DHistory::retrievePreviousState() {
	TASK previousState;
	previousState = previousStateStack.top();
	previousStateStack.pop();
	return previousState;
}

void E2DHistory::reverseClear() {
	E2DStorage::undoClear(previousTodayUpcomingTaskList, previousFloatingTaskList);
	previousTodayUpcomingTaskList.clear();
	previousFloatingTaskList.clear();
	return;
}

void E2DHistory::pushPreviousTodayUpcomingTaskList(std::vector<TASK>& taskList) {
	std:: vector<TASK>::iterator iter;
	for(iter = taskList.begin(); iter != taskList.end(); iter++) {
		previousTodayUpcomingTaskList.push_back(*iter);
	}
	return;
}

void E2DHistory::pushPreviousFloatingTaskList(std::vector<TASK>& taskList) {
	std:: vector<TASK>::iterator iter;
	for(iter = taskList.begin(); iter != taskList.end(); iter++) {
		previousFloatingTaskList.push_back(*iter);
	}
	return;
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DHistory.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DHistory.h
	 */

#ifndef E2DHISTORY_H_
#define E2DHISTORY_H_

#include <stack>
#include <sstream>
#include <vector>

#include "E2DStorage.h"

// this class allows the users to undo the previous functions that he executed. this function can be executed infinitely
// this function is extended to add, update, delete, clear, done
// it does not support save, filter, search as the reverse action would be display.
// this mechanism uses the idea of two stacks to store the previousAction and the previousState
// after every valid action that is supported by undo, it will be pushed into the previousState
// the previous task of action will be stored
// the only unique case will be clear where the updating state and the new state is stored
class E2DHistory {
private:
	static std:: stack<std:: string> previousActionStack;
	static std:: stack<TASK> previousStateStack;
	static const int MAXIMUM = 255;
	static char temp[MAXIMUM];
	static std:: vector<TASK> previousTodayUpcomingTaskList;
	static std:: vector<TASK> previousFloatingTaskList;
	
	static const std:: string MESSAGE_ERROR;
	static const std:: string MESSAGE_UNDO;
	static const std:: string SEVERITY_LEVEL_ERROR;

	static const std:: string COMMAND_ADD;
	static const std:: string COMMAND_SHORTCUT_ADD;
	static const std:: string COMMAND_DELETE;
	static const std:: string COMMAND_SHORTCUT_DELETE;
	static const std:: string COMMAND_CLEAR;
	static const std:: string COMMAND_SHORTCUT_CLEAR;
	static const std:: string COMMAND_EXIT;
	static const std:: string COMMAND_UNDO;
	static const std:: string COMMAND_DONE;
	static const std:: string COMMAND_SHORTCUT_DONE;
	static const std:: string COMMAND_UPDATE;
	static const std:: string COMMAND_SHORTCUT_UPDATE;
public:
	E2DHistory(void);
	~E2DHistory(void);

	enum CommandType { 
		ADD, EXIT, DELETE, INVALID, CLEAR, UPDATE, UNDO, DONE
	};

	// this function allow E2DLogic::executeCommand to store the previousAction
	// Pre: add, delete, update, clear, done
	// Post: store the string command in a stack
	static void addPreviousAction(std:: string commandAction);
	// similarly, this function store the state. However, this function is called from the E2DStorage when the command is being executed
	// Pre: same
	// Post: previous intended task is stored in a stack
	static void addPreviousState(TASK input);
	static bool isUndoStackEmpty();
	
	// this group of function basically execute the action retrieve on the top of stack.
	// undoAction retrieve the top of the stack
	// executeUndo does the thinking to execute whichever command
	// the followings are the supporting function
	// Pre: stack not empty
	// Post: return a feedback string and execute the command
	static std:: string undoAction();
	static void executeUndo(std:: string previousCommand);
	static CommandType E2DHistory::determineCommandType(std:: string commandAction);
	static bool isValidCommand(const std:: string& str1, const std:: string& str2);
	
	// this are the functions that undo support
	static void reverseDelete();
	static void reverseAdd();
	static void reverseUpdate();
	static void reverseDone();
	static TASK retrievePreviousState();

	// this function allow the user to undo the previous clear all/today/all/misc
	// the supporting functions allow the storage to push the temp taskList to be stored in History to undo the clear function
	// Pre: none
	// Post: reverse the clear action
	static void reverseClear();
	static void pushPreviousTodayUpcomingTaskList(std:: vector<TASK>& masterTaskList);
	static void pushPreviousFloatingTaskList(std:: vector<TASK>& masterTaskList);
};

#endif
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DHistory.h





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DLogging.cpp
	 */

#include "E2DLogging.h"

const std:: string E2DLogging::LOG_FILENAME = "logFile.txt";
const std:: string E2DLogging::MESSAGE_LINENUMBER = "line number: ";
int counter = 1; 

E2DLogging::E2DLogging(void) {
}


E2DLogging::~E2DLogging(void) {
}


void E2DLogging::logToFile(std:: string severity, std:: string fileName, std:: string lineNumber, std:: string message) {
	date dateToday;
	time_duration time;
	std:: ofstream LOG;
	LOG.open(LOG_FILENAME, std:: ios::out | std:: ios::app);

	dateToday = retrieveDateToday();
	time = retrieveTimeNow();

	LOG << to_simple_string(dateToday) << ", " << to_simple_string(time) << ", " << fileName + " @ " << MESSAGE_LINENUMBER << lineNumber << std:: endl;
	LOG << std:: to_string(counter) << ". " << severity << ", " << message << std:: endl << std:: endl;
	counter++;
	LOG.close();
	return;
}

date E2DLogging::retrieveDateToday() {
	ptime today = second_clock::local_time();
	date dateToday = today.date();
	return dateToday;
}

time_duration E2DLogging::retrieveTimeNow() {
	ptime today = second_clock::local_time();
	time_duration time = today.time_of_day();
	return time;
}

	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DLogging.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DLogging.h
	 */

#ifndef E2DLOGGING_H_
#define E2DLOGGING_H_

#include <string>
#include <fstream>
#include <boost/date_time.hpp>

using namespace boost::posix_time;
using namespace boost::gregorian;

// this class allows the users to log the information into an external file which is standardised to the logFile in 
// the UI folder
// the information being logged will be the severity level, filename, line number, time, message
// to serve as black box for the developer to trace the errors and warnings
class E2DLogging {
private:
	static const std:: string LOG_FILENAME;
	static const std:: string MESSAGE_LINENUMBER;
public:
	E2DLogging(void);
	~E2DLogging(void);

	// this function allow the developer and user to keep track of the errors
	// Pre: the error or assertion or exception must be violated for this function to be called
	// Post: log into the file
	static void logToFile(std:: string severity, std:: string fileName, std:: string lineNumber, std:: string message);
	static date retrieveDateToday();
	static time_duration retrieveTimeNow();

};
#endif
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DLogging.h





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DSaveLoad.cpp
	 */

#include "E2DSaveLoad.h"
#include "E2DLogging.h"

std:: string E2DSaveLoad::_taskDescription;
std:: string E2DSaveLoad::_startDateTime;
std:: string E2DSaveLoad::_endTime;
std:: string E2DSaveLoad::_endDateTime;
std:: string E2DSaveLoad::_taskID;
std:: string E2DSaveLoad::_done;
std:: string E2DSaveLoad::_newTask;
std:: string E2DSaveLoad::_overdue;
std:: string E2DSaveLoad::_clash;
std:: vector<TASK> E2DSaveLoad::_tempVector;
std:: vector<TASK> E2DSaveLoad::_tempMasterVector;
std:: vector<TASK> E2DSaveLoad::_tempFloatingVector;

std:: string E2DSaveLoad::_fileName;
std:: string E2DSaveLoad::_directoryName;
std:: string E2DSaveLoad::_pathName;

const std:: string E2DSaveLoad::DEFAULT_PATHNAME = "C:\\Users\\Default\\Desktop\\EasyToDo.txt";
const std:: string E2DSaveLoad::DEFAULT_TEXTFILENAME = "EasyToDo.txt";
const std:: string E2DSaveLoad::STORAGELOCATION_FILENAME = "pathName.txt";
const std:: string E2DSaveLoad::DEFAULT_DIRECTORYNAME = "C:\\Users\\Default\\Desktop\\";
const std:: string E2DSaveLoad::MESSAGE_DEFAULT_SAVE = "Save directory and filename is set to default!";
const std:: string E2DSaveLoad::MESSAGE_SUCCESSFUL_SAVE = "Save directory and filename changed!";
const std:: string E2DSaveLoad::MESSAGE_FAILED_SAVE = "Sorry. Invalid directory! Save directory not changed";

const std:: string E2DSaveLoad::SEVERITY_LEVEL_INFO = "Info";

char E2DSaveLoad::transitory[MAXIMUM];

E2DSaveLoad::E2DSaveLoad(void) {
}


E2DSaveLoad::~E2DSaveLoad(void) {
}

void:: E2DSaveLoad::initializePathName() {
	std:: ofstream initialize;
	initialize.open(STORAGELOCATION_FILENAME);
	initialize << DEFAULT_PATHNAME;
	initialize.close();
	return;
}

void E2DSaveLoad::saveToTextFile(std:: vector<TASK>& masterTaskList, std:: vector<TASK>& floatingTaskList) {
	std:: vector<TASK>::iterator iter;
	std:: ofstream saveFile(retrievePathName());
	std:: vector<TASK> taskList;
	
	taskList = combineVector(masterTaskList, floatingTaskList);

	for(iter = taskList.begin(); iter != taskList.end(); iter++) {
		saveFile << iter->taskDescriptionList;
		saveFile << std:: endl;

		saveFile << boost::posix_time::to_simple_string(iter->startDateTime).c_str();
		saveFile << std:: endl;

		saveFile << boost::posix_time::to_simple_string(iter->endTime).c_str();
		saveFile << std:: endl;

		saveFile << boost::posix_time::to_simple_string(iter->endDateTime).c_str();
		saveFile << std:: endl;

		saveFile << std:: to_string(iter->taskID);
		saveFile << std:: endl;

		saveFile << boost::lexical_cast<std::string>(iter->done);
		saveFile << std:: endl;

		saveFile << boost::lexical_cast<std::string>(iter->newTask);
		saveFile << std:: endl;
		
		saveFile << boost::lexical_cast<std::string>(iter->overdue);
		saveFile << std:: endl;

		saveFile << boost::lexical_cast<std::string>(iter->clash);

		if (iter != taskList.end() - 1) {
			saveFile << std:: endl;
		}		
	}
	saveFile.close();  
}

std:: string E2DSaveLoad::retrievePathName() {
	std:: ifstream read(STORAGELOCATION_FILENAME);
	std:: string line;
	getline(read,line);
	return line;
}

std:: vector<TASK> E2DSaveLoad::combineVector(std:: vector<TASK>& masterTaskList, std:: vector<TASK>& floatingTaskList) {
	std:: vector<TASK>::iterator iter;
	std:: vector<TASK> tempVector;

	for(iter = masterTaskList.begin(); iter != masterTaskList.end(); iter++) {
		tempVector.push_back(*iter);
	}

	for(iter = floatingTaskList.begin(); iter != floatingTaskList.end(); iter++) {
		tempVector.push_back(*iter);
	}

	return tempVector;
}

bool E2DSaveLoad::loadFromTextFile() {
	std:: string buffer;
	std:: vector<std:: string> tempStringVector;

	std:: ifstream readFile(retrievePathName());
	
	if (!readFile.is_open()) { // if file doesn't exists
		E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__ , std:: to_string(__LINE__), "file does not exist");
		std:: ofstream writeFile(retrievePathName());
		writeFile.close();
		return false;
	} else {
		while (std:: getline(readFile,buffer)) {
			tempStringVector.push_back(buffer);
		} 

		initializeTempVector(tempStringVector);
		differentiateVector(_tempVector);
		readFile.close();
		return true;
	}
}

void E2DSaveLoad::initializeTempVector(std:: vector<std:: string>& tempStringVector) {
	int size = tempStringVector.size();
	int i=0;
	TASK temp;

	while (i<size) {
		_taskDescription = tempStringVector[i];
		i++;
		_startDateTime = tempStringVector[i];
		i++;
		_endTime = tempStringVector[i];
		i++;
		_endDateTime = tempStringVector[i];
		i++;
		_taskID = tempStringVector[i];
		i++;
		_done = tempStringVector[i];
		i++;
		_newTask = tempStringVector[i];
		i++;
		_overdue = tempStringVector[i];
		i++;
		_clash = tempStringVector[i];
		i++;

		temp = initializeTaskFromString();
		_tempVector.push_back(temp);
	}
}

TASK E2DSaveLoad::initializeTaskFromString() {

	TASK temp;

	temp.taskDescriptionList = _taskDescription;

	ptime stringDateTime;
	boost::posix_time::time_input_facet *timeFacet = new boost::posix_time::time_input_facet;
    timeFacet->format("%Y-%b-%d %H:%M");
	std::istringstream iss(_startDateTime);
    iss.imbue(std::locale(std::locale::classic(), timeFacet));
	iss >> stringDateTime;
	temp.startDateTime = stringDateTime;

	temp.startTime = stringDateTime.time_of_day();

	ptime stringTimeDuration;
	boost::posix_time::time_input_facet *timeFacetEnd = new boost::posix_time::time_input_facet;
	timeFacetEnd->format("%Y-%b-%d %H:%M");
	std::istringstream ss(_endDateTime);
	ss.imbue(std::locale(std::locale::classic(), timeFacet));
	ss >> stringTimeDuration;
	temp.endDateTime = stringTimeDuration;

	temp.endTime = stringTimeDuration.time_of_day();

	temp.taskID =  atoi(_taskID.c_str());
	temp.done = boost::lexical_cast<bool>(_done);
	temp.newTask = boost::lexical_cast<bool>(_newTask);
	temp.overdue = boost::lexical_cast<bool>(_overdue);
	temp.clash = boost::lexical_cast<bool>(_clash);

	return temp;
}

void E2DSaveLoad::differentiateVector(std:: vector<TASK>& vector) {
	std:: vector<TASK>::iterator iter;

	for(iter = vector.begin(); iter != vector.end(); iter++) {
		if(iter->endTime.is_not_a_date_time() && iter->startDateTime.is_not_a_date_time()) {
			_tempFloatingVector.push_back(*iter);
		} else {
			_tempMasterVector.push_back(*iter);
		}
	}
	return;
}

std:: vector<TASK> E2DSaveLoad::passMasterTaskVector() {
	return _tempMasterVector;
}

std:: vector<TASK> E2DSaveLoad::passFloatingTaskVector() {
	return _tempFloatingVector;
}

std:: string E2DSaveLoad::changeSavingDirectoryAndFileName(std:: string directoryName, std:: string fileName) {
	try {
		if(directoryName == "" && fileName == "") {
			E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__ , std:: to_string(__LINE__), MESSAGE_DEFAULT_SAVE + ": " + DEFAULT_PATHNAME);
			_pathName = DEFAULT_PATHNAME;
			changePathName(_pathName);
			throw MESSAGE_DEFAULT_SAVE;
		} else {
			initializeDefaultPathAndFileName(directoryName, fileName);
			_pathName =  concatenateString(_directoryName, _fileName);

			if (isPathNameValid(_directoryName)) { 
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__ , std:: to_string(__LINE__), MESSAGE_SUCCESSFUL_SAVE + ": " + _pathName);
				changePathName(_pathName);
				throw MESSAGE_SUCCESSFUL_SAVE;
			} else {
				E2DLogging::logToFile(SEVERITY_LEVEL_INFO, __FILE__ , std:: to_string(__LINE__), MESSAGE_FAILED_SAVE + ": " + _pathName);
				throw MESSAGE_FAILED_SAVE;
			}
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(transitory, exceptionMessage.c_str());
		return transitory;
	}
}

void E2DSaveLoad::changePathName(std:: string newPathName) {
	std:: ofstream file;
	file.open(STORAGELOCATION_FILENAME);
	file << newPathName;
	file.close();
}

void E2DSaveLoad::initializeDefaultPathAndFileName(std:: string directoryName, std:: string fileName) {
	if(fileName == "") {
		_fileName = DEFAULT_TEXTFILENAME;
	} else {
		_fileName = fileName;
	}

	if(directoryName == "") {
		_directoryName = DEFAULT_DIRECTORYNAME;
	} else {
		_directoryName = directoryName;
	} 
	return;
}

bool E2DSaveLoad::isPathNameValid(std:: string directoryName) {
	if (boost::filesystem::exists(directoryName)) { 
		return true;
	} else {
		return false;
	}
}

std:: string E2DSaveLoad::concatenateString(std:: string _directoryName, std:: string _fileName) {
	return _directoryName + _fileName;
}

	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DSaveLoad.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DSaveLoad.h
	 */

#ifndef E2DSAVELOAD_H_
#define E2DSAVELOAD_H_

#include <sstream>
#include <fstream>
#include <vector>
#include <boost/filesystem.hpp>

#include "E2DStorage.h"

// this class execute writing and reading tasks details into external textfile as well as the capability to enable user to specify
// the file directory and file name
class E2DSaveLoad
{
private:
	static std:: string _taskDescription;
	static std:: string _startDateTime;
	static std:: string _endTime;
	static std:: string _endDateTime;
	static std:: string _taskID;
	static std:: string _done;
	static std:: string _newTask;
	static std:: string _overdue;
	static std:: string _clash;
	static std:: vector<TASK> _tempVector;
	static std:: vector<TASK> _tempMasterVector;
	static std:: vector<TASK> _tempFloatingVector;

	static std:: string _fileName;
	static std:: string _directoryName;
	static std:: string _pathName;
	
	static const std:: string DEFAULT_PATHNAME;
	static const std:: string DEFAULT_TEXTFILENAME;
	static const std:: string DEFAULT_DIRECTORYNAME;
	static const std:: string STORAGELOCATION_FILENAME;
	static const std:: string MESSAGE_DEFAULT_SAVE;
	static const std:: string MESSAGE_SUCCESSFUL_SAVE;
	static const std:: string MESSAGE_FAILED_SAVE;
	static const std:: string SEVERITY_LEVEL_INFO;
	static const int MAXIMUM = 255;
	static char transitory[MAXIMUM];
public:
	E2DSaveLoad(void);
	~E2DSaveLoad(void);
	
	// this function is called by E2DStorage when there isn't an existing pathname to store a default pathname
	// in other words, the user did not specify a save file directory and filename before he starts to input tasks onto the commandline
	// as such this function create a pathname.txt when the program fail to load from an existing file
	// Pre: None
	// Post: a pathName.txt created in the UI folder in the project file which contains the default pathname 
	// "C:\\Users\\Choo\\Desktop\\EasyToDo.txt"
	static void initializePathName();

	// this function is called every single time an action is executed successfully in the logic
	// this duplicates the tasks in the two vectors(combined by the function 'combineVector') 
	// and write them on the textfile at the specific path and filename retrieved from PathName.txt
	// Pre: None
	// Post: txt file created in the specific directory 
	static void saveToTextFile(std:: vector<TASK>& masterTaskList, std:: vector<TASK>& floatingTaskList);
	static std:: string retrievePathName();
	static std:: vector<TASK> combineVector(std:: vector<TASK>& masterTaskList, std:: vector<TASK>& floatingTaskList);

	// this function retrieve the tasks details from the path location as stated in the pathName.txt 
	// utilising the supporting function, initializeTempVector, to intialize individual tasks 
	// using the supporting function, differtiateVector, will separate the tasks into their respective vector(taskList)
	// Pre: it will only read if the file exist in the path location
	// Post: allow for pre-exit vectors to be available again
	static bool loadFromTextFile();
	static void initializeTempVector(std:: vector<std:: string>& tempStringVector);
	static TASK initializeTaskFromString();
	static void differentiateVector(std:: vector<TASK>& vector);

	// this two functions allow storage to call them to retrieve the duplicated copies of vector<TASK> created according to the textfile
	// Pre: text file must exist and must not be empty
	// Post: the masterTaskList and FloatingTaskList will be initialized according to the E2DSaveLoad
	static std:: vector<TASK> passMasterTaskVector();
	static std:: vector<TASK> passFloatingTaskVector();
	
	// this function allow the user to have the flexible to specify his own path location and filename
	// if the input is simply 'save', the file directory and filename will be set to default
	// or any of the input is determined to be empty, it will be set to empty
	// basically, i have an external default pathname.txt that will store the pathname which will either be default or specified by the user
	// using the function, changePathName, we change the path location in the pathName.txt which save and load will retrieve from
	static std:: string changeSavingDirectoryAndFileName(std:: string directoryName, std:: string fileName);
	static void changePathName(std:: string newPathName);
	static void initializeDefaultPathAndFileName(std:: string directoryName, std:: string fileName);
	static bool isPathNameValid(std:: string directoryName);
	static std:: string concatenateString(std:: string _directoryName, std:: string _fileName);

};
#endif

	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DSaveLoad.h





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DStorage.cpp
	 */

#include "E2DStorage.h"
#include "E2DBoost.h"
#include "E2DSaveLoad.h"
#include "E2DHistory.h"
#include "E2DLogging.h"

std:: vector<TASK> E2DStorage::masterTaskList; 
std:: vector<TASK> E2DStorage::todayTaskList;
std:: vector<TASK> E2DStorage::upcomingTaskList;
std:: vector<TASK> E2DStorage::floatingTaskList;
std:: vector<TASK> E2DStorage::tempFloatingTaskList;

const std:: string E2DStorage::DEFAULT_HOURS = "23";
const std:: string E2DStorage::DEFAULT_MINUTES = "59";
const std:: string E2DStorage::STRING_BLANK = "";

const std:: string E2DStorage::MESSAGE_FILTER_UNSUCCESSFUL = "Sorry, no match found!";
const std:: string E2DStorage::MESSAGE_FILTER_DATE_SUCCESSFUL = "The following task(s) displayed is/are the upcoming task(s) from the date you keyed";
const std:: string E2DStorage::MESSAGE_FILTER_TIME_SUCCESSFUL = "The following task(s) displayed is/are the upcoming task(s) from the time you keyed";

const std:: string E2DStorage::MESSAGE_SEARCH_UNSUCCESSFUL = "Sorry, no match found!";
const std:: string E2DStorage::MESSAGE_SEARCH_SUCCESSFUL = "The following task(s) displayed is/are the task(s) that contain(s) your intended search input";

const std:: string E2DStorage::DEFAULT_YEAR = "2015,";

const std:: string E2DStorage::SEVERITY_LEVEL_WARNING = "Warning";
const std:: string E2DStorage::MESSAGE_LOG_INVALID = "Invalid User Input";


char E2DStorage::buffer[MAX];

// this function allows the algorithm to execute the find function in our context to compare the respective content of the task struct
bool operator==(const TASK& a, const TASK& b) {
	return (a.taskDescriptionList == b.taskDescriptionList) && (a.startDateTime == b.startDateTime) && (a.endTime == b.endTime);
}

E2DStorage::E2DStorage(void) {
}


E2DStorage::~E2DStorage(void) {
}


void E2DStorage::updateTaskID(std:: vector<TASK>& input) {
	int counter = 1;
	std:: vector<TASK>::iterator iter;
	
	for(iter = input.begin(); iter != input.end(); iter++, counter++) {
		iter->taskID = counter;
	}
}

bool E2DStorage::loadProgram() {
	
	if (E2DSaveLoad::loadFromTextFile()) {
		masterTaskList.clear();
		floatingTaskList.clear();
		masterTaskList = E2DSaveLoad::passMasterTaskVector();
		floatingTaskList = E2DSaveLoad::passFloatingTaskVector();
		E2DBoost::sortTodayUpcoming(masterTaskList);
		return true;
	} else {
		E2DSaveLoad::initializePathName();
		return false;
	}
}

void E2DStorage::addToMasterStorage(std:: string _contentDescripton, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
											 std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes) {
	TASK temp;
	updateNewTask();
	E2DBoost::sortTodayUpcoming(masterTaskList);

	
	// not a timed task
	if(_contentEndHours == STRING_BLANK && _contentEndMinutes == STRING_BLANK) {
		// not a dateline task -> it is a floating task
		if(_contentStartHours == STRING_BLANK && _contentStartMinutes == STRING_BLANK && _contentStartDay == STRING_BLANK && _contentStartMonth == STRING_BLANK) {
			temp = initializeFloatingTask(_contentDescripton);
			floatingTaskList.push_back(temp);
			E2DHistory::addPreviousState(temp);
			saveProgram();
			return;
		} else {
			// if the task has startday and startmonth but doesn't have a time, it will initialise to default time as all-day task
			if(_contentStartHours == STRING_BLANK && _contentStartMinutes == STRING_BLANK) {
				_contentStartHours = DEFAULT_HOURS;
				_contentStartMinutes = DEFAULT_MINUTES;
				temp = initializeDeadlineTask(_contentDescripton, _contentStartDay, _contentStartMonth, _contentStartHours, _contentStartMinutes);
			} else {
				temp = initializeDeadlineTask(_contentDescripton, _contentStartDay, _contentStartMonth, _contentStartHours, _contentStartMinutes);
			}
		}
	} else {
		temp = initializeTimedTask(_contentDescripton, _contentStartDay, _contentStartMonth, _contentStartHours, _contentStartMinutes, _contentEndDay, _contentEndMonth, _contentEndHours, _contentEndMinutes);
	}

	E2DHistory::addPreviousState(temp);
	masterTaskList.push_back(temp);
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::updateNewTask() {
	std:: vector<TASK>::iterator iter;
	for(iter = floatingTaskList.begin(); iter != floatingTaskList.end(); iter++) {
		iter->newTask = false;
	}

	for(iter = masterTaskList.begin(); iter != masterTaskList.end(); iter++) {
		iter->newTask = false;
	}
}

TASK E2DStorage::initializeFloatingTask(std:: string _contentDescription) {
	assert(_contentDescription != STRING_BLANK);

	TASK buffer;
	buffer.taskDescriptionList = _contentDescription;
	ptime temp; //temp => not_a_date_time
	buffer.startDateTime = temp;
	buffer.endTime = time_duration(not_a_date_time);
	buffer.endDateTime = temp;
	buffer.taskID = 0;
	buffer.done = false;
	buffer.newTask = true;
	buffer.overdue = false;
	buffer.clash = false;
	return buffer;
}

TASK E2DStorage::initializeDeadlineTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, std:: string _contentStartMinutes) {
	assert(_contentDescription != STRING_BLANK);
	assert(_contentStartDay != STRING_BLANK);
	assert(_contentStartMonth != STRING_BLANK);
	assert(_contentStartHours != STRING_BLANK);
	assert(_contentStartMinutes != STRING_BLANK);

	TASK buffer;
	buffer.taskDescriptionList = _contentDescription;
	std::string dateString; 

	dateString = DEFAULT_YEAR + _contentStartMonth + "," + _contentStartDay;
	date d(from_string(dateString));
	ptime temp(d, time_duration(hours(stringToInt(_contentStartHours))+minutes(stringToInt(_contentStartMinutes))));
	buffer.startDateTime = temp;
	buffer.startTime = temp.time_of_day();

	ptime temp1;
	buffer.endDateTime = temp1;
	buffer.endTime = time_duration(not_a_date_time);
	
	buffer.taskID = 0;
	buffer.done = false;
	buffer.newTask = true;
	buffer.overdue = false;
	buffer.clash = false;
	return buffer;
}

TASK E2DStorage::initializeTimedTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
											  std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes) {
	assert(_contentDescription != STRING_BLANK);
	assert(_contentStartDay != STRING_BLANK);
	assert(_contentStartMonth != STRING_BLANK);
	assert(_contentStartHours != STRING_BLANK);
	assert(_contentStartMinutes != STRING_BLANK);
	assert(_contentEndHours != STRING_BLANK);
	assert(_contentEndMinutes != STRING_BLANK);

	TASK buffer;
	buffer.taskDescriptionList = _contentDescription;
	std::string startDateString; 
	std::string endDateString; 

	startDateString = DEFAULT_YEAR +  _contentStartMonth + "," + _contentStartDay;
	date d1(from_string(startDateString));
	ptime temp1(d1, time_duration(hours(stringToInt(_contentStartHours))+minutes(stringToInt(_contentStartMinutes))));
	buffer.startDateTime = temp1;
	buffer.startTime = temp1.time_of_day();

	// if the user did not specify the endDay and endMonth, it will be assumed that they are the same as the startday and month
	if(_contentEndDay == STRING_BLANK && _contentEndMonth == STRING_BLANK) {
		_contentEndDay = _contentStartDay;
		_contentEndMonth = _contentStartMonth;
	}

	endDateString = DEFAULT_YEAR +  _contentEndMonth + "," + _contentEndDay;
	date d2(from_string(endDateString));
	ptime temp2(d2,time_duration(hours(stringToInt(_contentEndHours))+minutes(stringToInt(_contentEndMinutes))));
	buffer.endDateTime = temp2;
	buffer.endTime = temp2.time_of_day();
	
	buffer.taskID = 0;
	buffer.done = false;
	buffer.newTask = true;
	buffer.overdue = false;
	buffer.clash = false;
	return buffer;
}

int E2DStorage::stringToInt(std:: string input) {
	int value;
	value = atoi(input.c_str());
	return value;
}

void E2DStorage::deleteTodayFromStorage(std:: vector<TASK>::iterator iter) {
	deleteTask(*iter);
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::deleteUpcomingFromStorage(std:: vector<TASK>::iterator iter) {
	deleteTask(*iter);
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::deleteFloatingFromStorage(std:: vector<TASK>::iterator iter) {
	E2DHistory::addPreviousState(*iter);
	floatingTaskList.erase(iter);
	saveProgram();
	return;
}

void E2DStorage::deleteTask(TASK& input) {
	std::vector<TASK>::iterator position = std::find(masterTaskList.begin(), masterTaskList.end(), input);
	if (position == masterTaskList.end()) {
		position = std::find(floatingTaskList.begin(), floatingTaskList.end(), input);
		floatingTaskList.erase(position);
	}
	else {
		masterTaskList.erase(position);
		E2DBoost::sortTodayUpcoming(masterTaskList);
	}
	saveProgram();
	return;
}

void E2DStorage::clearAllFromStorage() {
	E2DHistory::pushPreviousTodayUpcomingTaskList(masterTaskList);
	E2DHistory::pushPreviousFloatingTaskList(floatingTaskList);
	masterTaskList.clear();
	floatingTaskList.clear();
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::clearTodayFromStorage() {
	E2DHistory::pushPreviousTodayUpcomingTaskList(masterTaskList);
	masterTaskList.clear();
	std:: vector<TASK>::iterator iter;
	for(iter = upcomingTaskList.begin(); iter != upcomingTaskList.end(); iter++) {
		masterTaskList.push_back(*iter);
	}
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::clearUpcomingFromStorage() {
	E2DHistory::pushPreviousTodayUpcomingTaskList(masterTaskList);
	masterTaskList.clear();
	std:: vector<TASK>::iterator iter;
	for(iter = todayTaskList.begin(); iter != todayTaskList.end(); iter++) {
		masterTaskList.push_back(*iter);
	}
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::clearFloatingFromStorage() {
	E2DHistory::pushPreviousTodayUpcomingTaskList(masterTaskList);
	E2DHistory::pushPreviousFloatingTaskList(floatingTaskList);
	floatingTaskList.clear();
	saveProgram();
	return;
}

void E2DStorage::updateToTodayStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
											   std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes) {
	std:: vector<TASK>::iterator iter = findTodayIterator(taskID);
	E2DHistory::addPreviousState(*iter);
	deleteTask(*iter);
	addToMasterStorage(newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);
	E2DBoost::sortTodayUpcoming(masterTaskList);
}

void E2DStorage::updateToUpcomingStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
											   std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes) {
	std:: vector<TASK>::iterator iter = findUpcomingIterator(taskID);
	E2DHistory::addPreviousState(*iter);
	deleteTask(*iter);
	addToMasterStorage(newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);	
	E2DBoost::sortTodayUpcoming(masterTaskList);
}

void E2DStorage::updateToFloatingStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
											   std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes) {
	std:: vector<TASK>::iterator iter = findFloatingIterator(taskID);
	E2DHistory::addPreviousState(*iter);
	floatingTaskList.erase(iter);
	addToMasterStorage(newTask, newStartDay, newStartMonth, newStartHours, newStartMinutes, newEndDay, newEndMonth, newEndHours, newEndMinutes);
	E2DBoost::sortTodayUpcoming(masterTaskList);
}

std:: vector<TASK>::iterator E2DStorage::findTodayIterator(int taskID) {
	std:: vector<TASK>::iterator iter; 
	iter = todayTaskList.begin() + taskID - 1;
	return iter;
}

std:: vector<TASK>::iterator E2DStorage::findUpcomingIterator(int taskID) {
	std:: vector<TASK>::iterator iter; 
	iter = upcomingTaskList.begin() + taskID - 1;
	return iter;
}

std:: vector<TASK>::iterator E2DStorage::findFloatingIterator(int taskID) {
	std:: vector<TASK>::iterator iter; 
	iter = floatingTaskList.begin() + taskID - 1;
	return iter;
}

void E2DStorage::undoDelete(TASK& input) {
	if (input.startDateTime == not_a_date_time) {
		floatingTaskList.push_back(input);
	}
	else {
		masterTaskList.push_back(input);
		E2DBoost::sortTodayUpcoming(masterTaskList);
	}
	saveProgram();
	return;
}

void E2DStorage::undoAdd(TASK& input) {
	deleteTask(input);
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::undoClear(std:: vector<TASK>& previousTodayUpcomingTaskList, 
						  std:: vector<TASK>& previousFloatingTaskList) {
	masterTaskList.clear(); 
	std:: vector<TASK>::iterator iter;
	for(iter = previousTodayUpcomingTaskList.begin(); iter != previousTodayUpcomingTaskList.end(); iter++) {
		masterTaskList.push_back(*iter);
	}

	for(iter = previousFloatingTaskList.begin(); iter != previousFloatingTaskList.end(); iter++) {
		floatingTaskList.push_back(*iter);
	}
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::undoDone(TASK& input) {
	std::vector<TASK>::iterator position = std::find(masterTaskList.begin(), masterTaskList.end(), input);

	if (position == masterTaskList.end()) {
		position = std::find(floatingTaskList.begin(), floatingTaskList.end(), input);
		position->done = false;
	}
	else {
		position->done = false;
		E2DBoost::sortTodayUpcoming(masterTaskList);
	}
	saveProgram();
	return;
}

void E2DStorage::doneTodayTask(std:: vector<TASK>::iterator iter) {
	std::vector<TASK>::iterator position = std::find(masterTaskList.begin(), masterTaskList.end(), *iter);
	position->done = true;
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::doneUpcomingTask(std:: vector<TASK>::iterator iter) {
	std::vector<TASK>::iterator position = std::find(masterTaskList.begin(), masterTaskList.end(), *iter);
	position->done = true;
	E2DBoost::sortTodayUpcoming(masterTaskList);
	saveProgram();
	return;
}

void E2DStorage::doneFloatingTask(std:: vector<TASK>::iterator iter) {
	iter->done = true;
	saveProgram();
	return;
}

std:: vector<TASK> E2DStorage::retrieveTodayTaskList() {
	return todayTaskList;
}

std:: vector<TASK> E2DStorage::retrieveUpcomingTaskList() {
	return upcomingTaskList;
}

std:: vector<TASK> E2DStorage::retrieveFloatingTaskList() {
	return floatingTaskList;
}

int E2DStorage::findTotalNumberofTodayTask() {
	return todayTaskList.size();
}

int E2DStorage::findTotalNumberofUpcomingTask() {
	return upcomingTaskList.size();
}

int E2DStorage::findTotalNumberofFloatingTask() {
	return floatingTaskList.size();
}

bool E2DStorage::isMasterTaskListEmpty() {
	if(masterTaskList.size() == 0) {
		return true;
	} else {
		return false;
	}
}

bool E2DStorage::isTodayTaskListEmpty() {
	if(todayTaskList.size() == 0) {
		return true;
	} else {
		return false;
	}
}

bool E2DStorage::isUpcomingTaskListEmpty() {
	if(upcomingTaskList.size() == 0) {
		return true;
	} else {
		return false;
	}
}

bool E2DStorage::isFloatingTaskListEmpty() {
	if(floatingTaskList.size() == 0) {
		return true;
	} else {
		return false;
	}
}


void E2DStorage::storeTodayTask(TASK temp) {
	temp = E2DBoost::checkClashTask(temp, todayTaskList);
	todayTaskList.push_back(temp);
	E2DBoost::sortWithinTodayUpcoming(todayTaskList);
	E2DBoost::checkOverdueTask(todayTaskList);
	saveProgram();
	return;
}

void E2DStorage::storeUpcomingTask(TASK temp) {
	temp = E2DBoost::checkClashTask(temp, upcomingTaskList);
	upcomingTaskList.push_back(temp);
	E2DBoost::sortWithinTodayUpcoming(upcomingTaskList);
	saveProgram();
	return;
}

void E2DStorage::clearTodayTaskList() {
	todayTaskList.clear();
	return;
}

void E2DStorage::clearUpcomingTaskList() {
	upcomingTaskList.clear();
	return;
}

void E2DStorage::updateClashStatus(TASK& task) {
	std::vector<TASK>::iterator position = std::find(masterTaskList.begin(), masterTaskList.end(), task);
	position->clash = true;
	E2DBoost::sortWithinTodayUpcoming(todayTaskList);
	saveProgram();
}

void E2DStorage::saveProgram() {
	E2DSaveLoad::saveToTextFile(masterTaskList, floatingTaskList);
}

std:: string E2DStorage::filterTaskByDayAndMonth(std:: string day, std:: string month) {
	std:: vector<TASK> tempTodayVector;
	std:: vector<TASK> tempUpcomingVector;
	
	
	date d = initializeDate(day, month);

	day = incrementDay(day);
	date d1 = initializeDate(day, month);

	day = incrementDay(day);
	date d2 = initializeDate(day, month);

	tempTodayVector = filteredTaskFromToday(d, d1, d2);
	tempUpcomingVector = filteredTaskFromUpcoming(d, d1, d2);
	
	try {
		if(tempTodayVector.empty() && tempUpcomingVector.empty()) {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found");
			throw MESSAGE_FILTER_UNSUCCESSFUL;
		} else {
			if(tempFloatingTaskList.empty()) {
				tempFloatingTaskList = floatingTaskList;
			}

			todayTaskList = tempTodayVector;
			upcomingTaskList = tempUpcomingVector;

			floatingTaskList.clear();
			throw MESSAGE_FILTER_DATE_SUCCESSFUL;
		}
		
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		saveProgram();
		return buffer;
	}
}

std:: string E2DStorage::filterTaskByHrAndMin(std:: string hour, std:: string min) {
	std:: vector<TASK> tempTodayVector;
	std:: vector<TASK> tempUpcomingVector;
	std:: vector<TASK>::iterator iter;

	time_duration td = hours(stringToInt(hour)) + seconds(stringToInt(min)); 

	for(iter = todayTaskList.begin(); iter != todayTaskList.end(); iter++) {
		if(isTimeFound(td, *iter)) {
			tempTodayVector.push_back(*iter);
		}
	}

	for(iter = upcomingTaskList.begin(); iter != upcomingTaskList.end(); iter++) {
		if(isTimeFound(td, *iter)) {
			tempUpcomingVector.push_back(*iter);
		}
	}

	try {
		if(tempTodayVector.empty() && tempUpcomingVector.empty()) {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found");
			throw MESSAGE_FILTER_UNSUCCESSFUL;
		} else {
			if(tempFloatingTaskList.empty()) {
				tempFloatingTaskList = floatingTaskList;
			}

			todayTaskList = tempTodayVector;
			upcomingTaskList = tempUpcomingVector;

			floatingTaskList.clear();
			throw MESSAGE_FILTER_TIME_SUCCESSFUL;
		}
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		saveProgram();
		return buffer;
	}
}

std:: string E2DStorage::incrementDay(std:: string day) {
	int temp;
	temp = stringToInt(day) + 1;
	day = std:: to_string(temp);
	return day;
}

date E2DStorage::initializeDate(std:: string day, std:: string month) {
	std:: string dateString;
	dateString = DEFAULT_YEAR + month + "," + day;
	date d(from_string(dateString));
	return d;
}

std:: vector<TASK> E2DStorage::filteredTaskFromToday(date d, date d1, date d2) {
	std:: vector<TASK>::iterator iter;
	std:: vector<TASK> temp;

	for(iter = todayTaskList.begin(); iter != todayTaskList.end(); iter++) {
		if(areDatesFound(d, d1, d2, *iter)) {
			temp.push_back(*iter);
		}
	}
	return temp;
}

std:: vector<TASK> E2DStorage::filteredTaskFromUpcoming(date d, date d1, date d2) {
	std:: vector<TASK>::iterator iter;
	std:: vector<TASK> temp;

	for(iter = upcomingTaskList.begin(); iter != upcomingTaskList.end(); iter++) {
		if(areDatesFound(d, d1, d2, *iter)) {
			temp.push_back(*iter);
		}
	}
	return temp;
}

bool E2DStorage::areDatesFound(date d, date d1, date d2, TASK& task) {
	if((task.startDateTime.date() == d) || (task.endDateTime.date() == d)
		|| (task.startDateTime.date() == d1) || (task.endDateTime.date() == d1) 
		|| (task.startDateTime.date() == d2) || (task.endDateTime.date() == d2)) {
			return true;
	} else {
		return false;
	}
}

bool E2DStorage::isTimeFound(time_duration td, TASK& task) {
	// if it contains a endTime -> timed task
	if(!task.endTime.is_not_a_date_time()) {
		time_period tp1(task.startDateTime, task.endDateTime);
		time_period tp2(task.startDateTime, ptime(task.startDateTime.date(), td));
		if(tp2.intersects(tp1)) {
			return true;
		} else {
			return false;
		}
	} else { // it does not contain a endTime -> deadline Task
		if(task.startTime == td) {
			return true;
		} else {
			return false;
		}
	}
}

void E2DStorage::displayTaskInStorage() {
	E2DBoost::sortTodayUpcoming(masterTaskList);
	floatingTaskList = tempFloatingTaskList;
	tempFloatingTaskList.clear();
	saveProgram();
	return;
}

std:: string E2DStorage::searchContentInStorage(std:: string& searchContent) {
	std:: vector<TASK> tempTodayVector;
	std:: vector<TASK> tempUpcomingVector;
	std:: vector<TASK> tempFloatingVector;
	
	tempTodayVector = searchInTodayTaskList(searchContent);
	tempUpcomingVector = searchInUpcomingTaskList(searchContent);
	tempFloatingVector = searchInFloatingTaskList(searchContent);

	try {
		if(tempTodayVector.empty() && tempUpcomingVector.empty() && tempFloatingVector.empty()) {
			E2DLogging::logToFile(SEVERITY_LEVEL_WARNING, __FILE__, std:: to_string(__LINE__), MESSAGE_LOG_INVALID + ": " + "taskID is not found");
			throw MESSAGE_SEARCH_UNSUCCESSFUL;
		} else {
			if(tempFloatingTaskList.empty()) {
				tempFloatingTaskList = floatingTaskList;
			}
			todayTaskList = tempTodayVector;
			upcomingTaskList = tempUpcomingVector;
			floatingTaskList = tempFloatingVector;
		}
		throw MESSAGE_SEARCH_SUCCESSFUL;
	} catch (std:: string& exceptionMessage) {
		sprintf_s(buffer, exceptionMessage.c_str());
		saveProgram();
		return buffer;
	}
}

std:: vector<TASK> E2DStorage::searchInTodayTaskList(std::string& searchContent) {
	std:: vector<TASK>::iterator iter;
	std::size_t found;
	std:: vector<TASK> temp;

	for(iter = todayTaskList.begin(); iter != todayTaskList.end(); iter++) {
		found = iter->taskDescriptionList.find(searchContent);
		if(found != std:: string::npos) {
			temp.push_back(*iter);
		}
	}
	return temp;
}

std:: vector<TASK> E2DStorage::searchInUpcomingTaskList(std::string& searchContent) {
	std:: vector<TASK>::iterator iter;
	std::size_t found;
	std:: vector<TASK> temp;

	for(iter = upcomingTaskList.begin(); iter != upcomingTaskList.end(); iter++) {
		found = iter->taskDescriptionList.find(searchContent);
		if(found != std:: string::npos) {
			temp.push_back(*iter);
		}
	}
	return temp;
}

std:: vector<TASK> E2DStorage::searchInFloatingTaskList(std::string& searchContent) {
	std:: vector<TASK>::iterator iter;
	std::size_t found;
	std:: vector<TASK> temp;

	for(iter = floatingTaskList.begin(); iter != floatingTaskList.end(); iter++) {
		found = iter->taskDescriptionList.find(searchContent);
		if(found != std:: string::npos) {
			temp.push_back(*iter);
		}
	}
	return temp;
}

std:: vector<TASK> E2DStorage::retrieveMasterTaskList(){
	return masterTaskList;
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DStorage.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DStorage.h
	 */

#ifndef E2DSTORAGE_H_
#define E2DSTORAGE_H_

#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <boost/date_time.hpp>
#include <assert.h>

using namespace boost::posix_time;
using namespace boost::gregorian;

// Timed: add meet ivy on 14 April from 14:00 to 18:00 
// (MISC)Floating: add meet ivy
// Deadline: add meet ivy on 14 april at 1400
struct TASK {
	std:: string taskDescriptionList;
	ptime startDateTime; 
	time_duration startTime;
	ptime endDateTime;
	time_duration endTime;
	int taskID;
	bool done; // check if the task is done. initialized as false
	bool newTask; // check if the task is recently added to EasyToDo to enable us to highlight the newest task added. initialized as true
	bool overdue; // check if the task is overdue else highlight in red. initialized as false.
	bool clash; // check if there is any task that have timeline that clashes with each other. initialized as false.
};

// this class, it where after the logic has processed the user's intention, execute the respective action and make changes to the variable
// stored in this class
class E2DStorage
{
private:
	static std:: vector<TASK> masterTaskList; // stores both timed and deadline task
	static std:: vector<TASK> floatingTaskList; 
	static std:: vector<TASK> todayTaskList;
	static std:: vector<TASK> upcomingTaskList;
	static std:: vector<TASK> tempFloatingTaskList;

	static const std:: string DEFAULT_HOURS;
	static const std:: string DEFAULT_MINUTES;
	static const std:: string STRING_BLANK;

	static const std:: string MESSAGE_FILTER_UNSUCCESSFUL;
	static const std:: string MESSAGE_FILTER_DATE_SUCCESSFUL;
	static const std:: string MESSAGE_FILTER_TIME_SUCCESSFUL;
	static const std:: string MESSAGE_SEARCH_UNSUCCESSFUL;
	static const std:: string MESSAGE_SEARCH_SUCCESSFUL;
	static const std:: string DEFAULT_YEAR;

	static const std:: string SEVERITY_LEVEL_WARNING;
	static const std:: string MESSAGE_LOG_INVALID;

	static const int MAX = 255;
	static char buffer[MAX];
public:
	E2DStorage(void);
	~E2DStorage(void);

	// the GUI will call this function for theindividual taskType column to get the numbering for the task to be displayed
	// Pre: None
	// Post: the taskID in the structure of the task is assigned with a number
	static void updateTaskID(std:: vector<TASK>& input);

	// the UI will actually call this function to retrieve the saved tasks in the textfile to initialise the taskLists
	// Pre: None 
	// Post: if true, the UI will pop out a window saying Welcome back to EasyToDo for repeated user and display whatever tasks saved previously
	// if false, the UI will pop out a window saying welcome to easyToDo for first time user. 
	static bool loadProgram();

	// this function call for supporting functions to initialise the task and add them into their respective task type
	// deadline and timed tasks are added to masterTaskList while floating are added to floating tasklist
	// the tasks in masterTaskList are then sorted into their individual taskList using Boost::sortTodayUpcoming
	// before adding any new task, it will call updateNewTask to change the bool of new to false for GUI to recognise
	// Pre: task != "" 
	// Post: Save the program after every action. 
	static void addToMasterStorage(std:: string _contentDescripton, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
											 std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes);
	static void updateNewTask();
	static TASK initializeFloatingTask(std:: string _contentDescription);
	static TASK initializeDeadlineTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
										std:: string _contentStartMinutes);
	static TASK initializeTimedTask(std:: string _contentDescription, std:: string _contentStartDay, std:: string _contentStartMonth, std:: string _contentStartHours, 
											  std:: string _contentStartMinutes, std:: string _contentEndDay, std:: string _contentEndMonth, std:: string _contentEndHours, std:: string _contentEndMinutes);
	static int stringToInt(std:: string input);

	// if the taskType is today or upcoming, this function calls for deleteTask to find the task in mastertasklit and remove it
	// and Boost::sortTodayUpcoming to update the today and upcoming TaskList
	// if the taskType is floating, it will simply remove the task from floatingtasklist
	// Pre: valid iter
	// Post: save program after every action
	static void deleteTodayFromStorage(std:: vector<TASK>::iterator iter);
	static void deleteUpcomingFromStorage(std:: vector<TASK>::iterator iter);
	static void deleteFloatingFromStorage(std:: vector<TASK>::iterator iter);
	static void deleteTask(TASK& input);
	
	// this function clears all the contents of the vector<TASK> in both masterTaskList and floatingTaskList
	// Pre: None
	// Post:: save program after every action
	static void clearAllFromStorage();
	// this function replaces the masterTaskList with the upcomingTaskList to remove all the todayTasks
	static void clearTodayFromStorage();
	// Similarly, this function replaces the masterTaskList with the todayTaskList to remove all the UpcomingTasks
	static void clearUpcomingFromStorage();
	// this function clear all the contents of the floatingTaskList
	static void clearFloatingFromStorage();

	// for update function, i will store two previous states instead of one[add, delete] 
	// thus the first one you pop from the stack "previousStateStack" would be the one you need to delete
	// and the second one would be the one you need to add back cause of LIFO
	// this function basically uses the addtoMasterStorage and deleteTask to execute update
	// this allow the user change one tasktype to another
	// Pre: pre-conditions are already fulfilled in logic
	// Post: Save the program after every action. 
	static void updateToTodayStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
									std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes);
	static void updateToUpcomingStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
									std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes);
	static void updateToFloatingStorage(int taskID, std:: string newTask, std:: string newStartDay, std:: string newStartMonth, std:: string newStartHours, 
									std:: string newStartMinutes, std:: string newEndDay, std:: string newEndMonth, std:: string newEndHours, std:: string newEndMinutes);
	static std:: vector<TASK>::iterator findTodayIterator(int taskID);
	static std:: vector<TASK>::iterator findUpcomingIterator(int taskID);
	static std:: vector<TASK>::iterator findFloatingIterator(int taskID);

	// this group of functions supports the functions in E2DHistory to execute the command undo
	// Pre: the stack sotring the previousAction is not empty
	// Post: execute the reverse action and save the program
	static void undoDelete(TASK& input);
	static void undoAdd(TASK& input);
	static void undoClear(std:: vector<TASK>& previousTodayUpcomingTaskList, std:: vector<TASK>& previousFloatingTaskList);
	static void undoDone(TASK& input);

	// this group of functions execute the user intention to strke out completed tasks. they change the bool done in the task struct 
	// Pre: valid iter
	// Post: change the bool from false to true and save program
	static void doneTodayTask(std:: vector<TASK>::iterator iter);
	static void doneUpcomingTask(std:: vector<TASK>::iterator iter);
	static void doneFloatingTask(std:: vector<TASK>::iterator iter);

	// this group of functions support the GUI's functions
	static std:: vector<TASK> retrieveTodayTaskList();
	static std:: vector<TASK> retrieveUpcomingTaskList();
	static std:: vector<TASK> retrieveFloatingTaskList();
	
	// this group of functions support E2DLogic's function to verify taskID
	static int findTotalNumberofTodayTask();
	static int findTotalNumberofUpcomingTask();
	static int findTotalNumberofFloatingTask();
	
	// this group of functions support E2DLogic's function for clearTask
	static bool isMasterTaskListEmpty();
	static bool isTodayTaskListEmpty();
	static bool isUpcomingTaskListEmpty();
	static bool isFloatingTaskListEmpty();

	// this group of functions support E2DBoost::sortTodayUpcoming
	// to differentiate the today and upcoming tasks
	// Pre: None
	// Post: masterTaskList will have a copy of all the today and upcoming tasks and the respective taskLists will contain their own tasks
	static void storeTodayTask(TASK temp);
	static void storeUpcomingTask(TASK temp);
	static void clearTodayTaskList();
	static void clearUpcomingTaskList();
	// when the tasks are differentiated into the task, this function is called to check if it clashes with any of the stored tasks
	// in the same taskList to update the bool clash
	// Pre: none
	// Post: check the clash period of the incoming task with all the stored tasks
	static void updateClashStatus(TASK& task);

	// this function calls save function in E2DSaveLoad to save the masterTaskList and floatingTextList to external text file
	// Pre: None
	// Post: according to the pathname stated in the PathName.txt(default or specify by user), the tasks are stored in the text file
	static void saveProgram();

	// this function allows the user to filter the task according to the dates. to aid jim, we will display tasks that are due in two days time from the intened date 
	// to give him ample time to complete his time 
	// Pre: the day and month must be valid inputs and the storage cannot be empty
	// Post: return a feedback string and input the tasks in the indivdual tasktype box
	static std:: string filterTaskByDayAndMonth(std:: string day, std:: string month);
	static std:: string filterTaskByHrAndMin(std:: string hour, std:: string min);
	static std:: string incrementDay(std:: string day); 
	static date initializeDate(std:: string day, std:: string month);
	static std:: vector<TASK> filteredTaskFromToday(date d, date d1, date d2);
	static std:: vector<TASK> filteredTaskFromUpcoming(date d, date d1, date d2);
	static bool areDatesFound(date d, date d1, date d2, TASK& task);
	static bool isTimeFound(time_duration td, TASK& task);

	// this function allow the user to display all the task once again if filter and search are successful
	// Pre: none
	// Post: display all the tasks in masterTaskList and floatingTaskList
	static void displayTaskInStorage();

	// this function allow the users to search through all the tasks for the intended content description
	// Pre: storage must not be empty
	// Post: return all the tasks that contain the user string in their individual boxes 
	static std:: string searchContentInStorage(std:: string& searchContent);
	static std:: vector<TASK> searchInTodayTaskList(std::string& searchContent);
	static std:: vector<TASK> searchInUpcomingTaskList(std::string& searchContent);
	static std:: vector<TASK> searchInFloatingTaskList(std::string& searchContent);

	// integration testing function
	static std:: vector<TASK> retrieveMasterTaskList();

};
#endif
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DStorage\E2DStorage.h





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\ClashTaskTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace EasyToDoTest
{		
	TEST_CLASS(EasyToDoTest)
	{
	public:
		
		TEST_METHOD(ClashTaskTest)
		{
			E2DParser parser;
			E2DStorage storage;
			E2DInputFeedback feedback;

			storage.clearAllFromStorage();
			storage.clearTodayFromStorage();
			storage.clearUpcomingFromStorage();
			storage.clearFloatingFromStorage();

			parser.pushUserInput("add meet ivy on 14 may 14:00");

			std:: vector<TASK> actualList = storage.retrieveUpcomingTaskList();
			Assert::IsTrue(!actualList[0].clash);

			parser.pushUserInput("add meet zx on 17 may 14:00");

			actualList = storage.retrieveUpcomingTaskList();
			Assert::IsTrue(!actualList[0].clash);

			parser.pushUserInput("add meet reub from 14 may 14:00 to 16 may 15:00");
			actualList = storage.retrieveUpcomingTaskList();
			Assert::IsTrue(actualList[0].clash);
			Assert::IsTrue(actualList[1].clash);
		}
	};
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\ClashTaskTest.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\ClearTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace EasyToDoTest
{		
	TEST_CLASS(EasyToDoTest)
	{
	public:

		TEST_METHOD(ClearTest)
		{
			E2DStorage storage;
			E2DBoost boost;
			size_t expected;
			std:: vector<TASK> actual;

			expected = 0;

			// clear all
			storage.addToMasterStorage("meet ivy", "4", "april", "17", "00", "", "", "", ""); 
			storage.addToMasterStorage("meet reuben", "4", "april", "18", "00", "", "", "", "");
			storage.addToMasterStorage("meet ivy", "27", "jun", "17", "00", "", "", "", ""); 
			storage.addToMasterStorage("meet reuben", "27", "jun", "18", "00", "", "", "", ""); 
			storage.clearAllFromStorage();
			actual = storage.retrieveMasterTaskList(); 
			Assert::AreEqual(expected,actual.size());

			// clear today
			storage.addToMasterStorage("meet ivy", "4", "april", "17", "00", "", "", "", ""); 
			storage.addToMasterStorage("meet reuben", "4", "april", "18", "00", "", "", "", ""); 
			storage.clearTodayFromStorage();
			actual = storage.retrieveTodayTaskList(); 
			Assert::AreEqual(expected,actual.size());

			// clear upcoming
			storage.addToMasterStorage("meet ivy", "27", "jun", "17", "00", "", "", "", ""); 
			storage.addToMasterStorage("meet reuben", "27", "jun", "18", "00", "", "", "", ""); 
			storage.clearUpcomingFromStorage();
			actual = storage.retrieveUpcomingTaskList();
			Assert::AreEqual(expected,actual.size());

			// clear float
			storage.addToMasterStorage("go to school", "", "", "", "", "", "", "", ""); 
			storage.addToMasterStorage("submit project", "", "", "", "", "", "", "", ""); 
			storage.clearFloatingFromStorage();
			actual = storage.retrieveFloatingTaskList();
			Assert::AreEqual(expected,actual.size());
		}		
	};
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\ClearTest.cpp





	/**
	 * origin: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\DeleteTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace EasyToDoTest
{		
	TEST_CLASS(EasyToDoTest)
	{
	public:

		TEST_METHOD(DeleteTest)
		{
			E2DStorage storageDelete;
			E2DParser parser;
			size_t expected;
			storageDelete.clearAllFromStorage();
			storageDelete.clearTodayFromStorage();
			storageDelete.clearUpcomingFromStorage();
			storageDelete.clearFloatingFromStorage();

			storageDelete.addToMasterStorage("meet ivy", "4", "april", "17", "00", "", "", "", "");
			storageDelete.addToMasterStorage("meet reuben", "4", "april", "18", "00", "", "", "", "");
			parser.pushUserInput("delete today 1");

			std:: vector<TASK> actual = storageDelete.retrieveTodayTaskList();  
			expected = 1; 
			Assert::AreEqual(expected,actual.size());

			storageDelete.addToMasterStorage("meet ivy", "27", "december", "17", "00", "", "", "", ""); 
			storageDelete.addToMasterStorage("meet reuben", "27", "april", "18", "00", "", "", "", "");

			expected = 2;
			actual = storageDelete.retrieveUpcomingTaskList(); 
			Assert::AreEqual(expected,actual.size());

			expected = 3; 
			actual = storageDelete.retrieveMasterTaskList(); 
			Assert::AreEqual(expected,actual.size());

			parser.pushUserInput("delete upcoming 1");
			expected = 1; 
			actual = storageDelete.retrieveUpcomingTaskList(); 
			Assert::AreEqual(expected,actual.size());

			storageDelete.addToMasterStorage("go to school", "", "", "", "", "", "", "", ""); 
			storageDelete.addToMasterStorage("submit project", "", "", "", "", "", "", "", "");
			expected = 2; 
			actual = storageDelete.retrieveFloatingTaskList(); 
			Assert::AreEqual(expected,actual.size());

			parser.pushUserInput("delete float 1");
			expected = 1; 
			actual = storageDelete.retrieveFloatingTaskList();
			Assert::AreEqual(expected,actual.size()); 
		}
	};
}
	// End of segment: C:\Users\Ivy\Documents\Visual Studio 2012\Projects\EasyToDo(updated)\E2DTest\DeleteTest.cpp





